[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SP",
    "section": "",
    "text": "modeling\n\n\npyomo\n\n\n\n\nCalculating shadow prices, reduced\n\n\n\n\n\n\nMar 12, 2023\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodeling\n\n\nscip\n\n\n\n\nWe are solving a some transport problems using pyscipopt and show how do sensitivity analysis.\n\n\n\n\n\n\nMar 12, 2023\n\n\ncbarz\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nmodeling\n\n\nscip\n\n\n\n\nWe are solving a some transport problems using pyscipopt and show how do sensitivity analysis.\n\n\n\n\n\n\nMar 4, 2023\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolver\n\n\n\n\nSCIP is of the fastest non-commercial solvers for MILP and MINLP. In this blog we give a quickstart to SCIP’s python interface pyscipopt.\n\n\n\n\n\n\nMar 3, 2023\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodeling\n\n\n\n\nTricks to transform a optimization model into a linear program\n\n\n\n\n\n\nNov 30, 2022\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nquarto\n\n\n\n\nQuick introduction to use citation and footnotes in quarto\n\n\n\n\n\n\nNov 29, 2022\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntest\n\n\n\n\njupyter notebook to test pyomo and solver installation\n\n\n\n\n\n\nNov 27, 2022\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngithub\n\n\n\n\nusing github actions\n\n\n\n\n\n\nSep 28, 2022\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npyomo\n\n\nmodeling\n\n\nscheduling\n\n\n\n\nSchedule jobs on a bottleneck machine and multiple machines\n\n\n\n\n\n\nJun 21, 2022\n\n\ncbarz\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npyomo\n\n\nmodeling\n\n\nblending\n\n\nproduct mix\n\n\n\n\nA simple example of a blending model. Given different ingredients we want to find a recipe for one product that fulfills certain requirements.\n\n\n\n\n\n\nJun 9, 2022\n\n\ncbarz\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\npyomo\n\n\nmodeling\n\n\nblending\n\n\nproduct mix\n\n\n\n\nA blending model with multiple products which fulfill certain requirements.\n\n\n\n\n\n\nJun 9, 2022\n\n\ncbarz\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "nbs/20221129_citation/index.html",
    "href": "nbs/20221129_citation/index.html",
    "title": "Citation and Footnotes in quarto",
    "section": "",
    "text": "footnotes:\n\nmarkdown footnote syntax (as I have to look this up regularly)\n\ncitations:\n\nexplain initial setup including a test\nexplain steps to generate citations and a bibliography with quarto"
  },
  {
    "objectID": "nbs/20221129_citation/index.html#input",
    "href": "nbs/20221129_citation/index.html#input",
    "title": "Citation and Footnotes in quarto",
    "section": "3.1 input",
    "text": "3.1 input\nHere is a footnote reference,[^1] and another.[^longnote]\n\n[^1]: Here is the footnote.\n[^longnote]: Here's one with multiple blocks.\n\n    Subsequent paragraphs are indented to show that they\nbelong to the previous footnote.\n\n        { some.code }\n\n    The whole paragraph can be indented, or just the first\n    line.  In this way, multi-paragraph footnotes work like\n    multi-paragraph list items.\n\nThis paragraph won't be part of the note, because it\nisn't indented.\nRemark: The content of the footnote, e.g. [^1]: Here is the footnote. can be placed anywhere in the document. I usually put it at the end of the document, because some footnotes are used more than once."
  },
  {
    "objectID": "nbs/20221129_citation/index.html#output",
    "href": "nbs/20221129_citation/index.html#output",
    "title": "Citation and Footnotes in quarto",
    "section": "3.2 output",
    "text": "3.2 output\nHere is a footnote reference,1 and another.2\nThis paragraph won’t be part of the note, because it isn’t indented."
  },
  {
    "objectID": "nbs/20221129_citation/index.html#inline-footnote",
    "href": "nbs/20221129_citation/index.html#inline-footnote",
    "title": "Citation and Footnotes in quarto",
    "section": "3.3 inline footnote",
    "text": "3.3 inline footnote\nHere is an inline note.^[Inlines notes are easier to write,\nsince you don't have to pick an identifier and move down to\ntype the note.]\nHere is an inline note.3"
  },
  {
    "objectID": "nbs/20221129_citation/index.html#bibliography-generation",
    "href": "nbs/20221129_citation/index.html#bibliography-generation",
    "title": "Citation and Footnotes in quarto",
    "section": "5.1 Bibliography Generation",
    "text": "5.1 Bibliography Generation\nSupose you want to add a new reference to your citation database references.bib, e.g. (Trotta et al. 2022). I usually do the following:\n\nopen google scholar\nsearch for your reference, e.g. “trotta routing on a ring”\nuse the nice link “citation” below the hit of google scholar and choose BibTex next\nsimply copy and paste the content to your references.bib file. The copied content will look like:\n\n@article{trotta2022pickup,\n  title={Pickup and delivery problems with autonomous vehicles on rings},\n  author={Trotta, Manuel and Archetti, Claudia and Feillet, Dominique and Quilliot, Alain},\n  journal={European Journal of Operational Research},\n  volume={300},\n  number={1},\n  pages={221--236},\n  year={2022},\n  publisher={Elsevier}\n}"
  },
  {
    "objectID": "nbs/20221129_citation/index.html#add-a-citation-in-a-blog-document",
    "href": "nbs/20221129_citation/index.html#add-a-citation-in-a-blog-document",
    "title": "Citation and Footnotes in quarto",
    "section": "5.2 Add a citation in a blog document",
    "text": "5.2 Add a citation in a blog document\n\nMarkdown format for citation is [@citation]\nGiven example: [@trotta2022pickup] renders to (Trotta et al. 2022)\nThere are other markdown format for citation, e.g. @trotta2022pickup renders to Trotta et al. (2022). For more information just have a look at the sources below."
  },
  {
    "objectID": "nbs/20220928_github_actions/index.html",
    "href": "nbs/20220928_github_actions/index.html",
    "title": "github actions",
    "section": "",
    "text": "This post explains how to set up a CI/CD with GitHub Actions. It expands predefined nbdev workflows, such that non python packages can be used.\n\n\nGitHub Actions allows us to automate our build, test, and deployment pipeline by continuous integration and continuous delivery (CI/CD).\nWe can create workflows to build and test every pull request to our repository. Whenever an event occurs a workflow is triggered. A workflow contains one or more jobs. In other words: We specify in a workflow what (jobs) should be done when (event).\nA workflow is stored as a YAML file in the .github/workflows directory.\nIn our case we had to modify a predefined workflow from nbdev, because we have to install some non python packages which require root write permissions.\nPrecisely; we want to use the glpk solver in a nbdev project and therefore define a workflow in the following example.\n\n\n\nWe first give the content of the yaml-file and explain its parts afterwards.\nname: stochprog_test\non: [push]\n\npermissions: write-all\n\njobs:\n  build:\n\n    runs-on: ubuntu-20.04\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python 3.9\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n      - name: install solver\n        run : sudo apt-get install -y libopenmpi-dev glpk-utils\n      - name: poetry install\n        run: |\n          python -m pip install --upgrade pip\n          curl -sSL https://install.python-poetry.org | python3 -\n          poetry install\n      - uses: fastai/workflows/quarto-ghp@master\n      - uses: fastai/workflows/nbdev-ci@master\n\n\nFirst we specify the name of the workflow. The given name will be displayed in the action tab of your github repository.\n\n\n\nThen we specify the events which will trigger the workflow. - for single event use on: push - for multiple events use on: [push, fork] - list of events that trigger workflows - there are many other activity types to trigger a workflow, e.g. issue creation\n\n\n\nWe can modify the permissions granted to the GITHUB_-_TOKEN. For simplicyty we did this for all scopes, but the permissions can be granted to to different scopes and specific jobs.\n\n\n\nA workflow is made of one or more jobs which specify what has to be done. Here build is the name of the job, which is defined afterwards. In the build job we define\n\nruns-on: ubuntu-20.04 specifies the type of machine the job runs on\nsteps list the tasks of the job\n\nEach step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps\nuses: uses: fastai/workflows/quarto-ghp@master runs an action of the fastai public repository\n\nAs the virtual Linux machines run passwordless we can use sudo without providing a password but add option -y to confirm the installation. Put together: run : sudo apt-get install -y libopenmpi-dev glpk-utils\n\n\n\n\n\n\nchaching dependencies to improve performance"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "",
    "text": "In this post we explain certain tools to investigate how an optimal solution changes when the input data changes. First we will introduce the notions and study how to do it in pyomo with the help of a small example.\nOne usage of these tool could be: Suppose we have factories with certain capacities producing certain products. We used a linear program to derive an optimal solution how to use our resources best. In this optimal setting some factories will running at their capacity limit. Now suppose we want to produce/sell more, hence we have to increase the capacities. Hence a natural question is which capacities should be increased first. Of course we could do simmulations using our linear program, but with the help of what we will see soon these information are allready available with our optimal solution.\n\n\n\npyomo suffixes\nsensitivity analysis\naccessing duals\nreduced costs\nshadow prices\nslack values"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#sets",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#sets",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "sets",
    "text": "sets\n\n\\(type\\) - chip type\n\\(process\\) - production process"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#variables",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#variables",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "variables",
    "text": "variables\n\n\\(x_i\\) produced amount of chip type \\(i \\in type\\)"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#parameters",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#parameters",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "parameters",
    "text": "parameters\n\n\\(profit_i\\) - profit of 1 kg of type \\(i\\) chip in $\n\\(avail_j\\) - available time for production process \\(j\\)\n\\(time_{ij}\\) - required time in min for 1 kg of type \\(i\\) chip and production process \\(j\\)"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#constraints",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#constraints",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "constraints",
    "text": "constraints\n\n(c1) time restriction on slicing\n(c2) time restriction on frying\n(c3) time restriction on packing\nproduction quantities are not negative"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#objective",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#objective",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "objective",
    "text": "objective\nMaximize net profit"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#model",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#model",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "model",
    "text": "model\n\\[\n\\begin{array}{lll}\n\\max & \\sum_{i\\in type} profit_i \\cdot x_i & \\\\\ns.t. & \\sum_{i\\in type} time_{ij} \\cdot x_i \\leq avail_j & \\forall j\\in process \\\\\n     & x_{i} \\leq 0 &\n\\end{array}\n\\]\n\nimport pyomo.environ as pyo\nimport json\n\n\ndata = {\n    \"Name\": \"Chip Shop\",\n    \"constraints\": {\n        'slicing': {'plain': 2, 'mexican': 4, 'availibility': 345},\n        'frying': {'plain': 4, 'mexican': 5, 'availibility': 480},\n        'packing': {'plain': 4, 'mexican': 2, 'availibility': 330},\n    },\n    \"profit\": {'plain': 2., 'mexican': 1.5},\n    \"Engine\": \"cbc\",\n    \"TimeLimit\": \"\"\n\n}"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#interlude-accessing-duals-in-pyomo",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#interlude-accessing-duals-in-pyomo",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "Interlude accessing duals in Pyomo",
    "text": "Interlude accessing duals in Pyomo\nIn order to extract the desired information we are using suffixes in pyomo. Suffixes provide a mechanism for declaring extraneous model data, which can be used in a number of contexts. The following code snippet shows how to declare a suffix component:\nm.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)"
  },
  {
    "objectID": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#chips-model",
    "href": "nbs/SensitivityAnalysis/01_sensitivity_analysis.html#chips-model",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "chips model",
    "text": "chips model\n\ndef chip_shop(data):    \n    m = pyo.ConcreteModel(data['Name'])\n    \n    #sets\n    m.types = pyo.Set(initialize = list(data['profit'].keys()))\n    m.process = pyo.Set(initialize = list(data['constraints'].keys()))\n    \n    # decision variables\n    m.x = pyo.Var(m.types, domain = pyo.NonNegativeReals, doc = 'produced packages of chip type i')\n    \n    \n    \n    # parameter\n    @m.Param(m.types, m.process, doc = 'processing time of product i in process j')\n    def time(m,i,j):\n        return data['constraints'][j][i]\n    @m.Param(m.process, doc = 'available processing time for process j')\n    def avail(m,j):\n        return data['constraints'][j]['availibility']\n    @m.Param(m.types, doc = 'net profits for product i')\n    def profit(m,i):\n        return data['profit'][i]\n    \n    # objective\n    m.OBJ = pyo.Objective(expr = pyo.quicksum(m.profit[i] * m.x[i] for i in m.types),\n                         sense = pyo.maximize)\n    \n    # constraints\n    @m.Constraint(m.process)\n    def c(m,j):\n        return pyo.quicksum(m.time[i,j] * m.x[i] for i in m.types) <= m.avail[j]\n    \n    # declaring a Suffix component - to access duals, slack, etc.\n    m.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)\n    \n    #extra components for output\n    m.optimaltime = pyo.Var(m.process, domain = pyo.NonNegativeReals)\n    @m.Constraint(m.process)\n    def opttime(m,j):\n        return m.optimaltime[j] == pyo.quicksum(m.time[i,j] * m.x[i] for i in m.types)\n    \n    # choosing and applying a solver\n    solver = pyo.SolverFactory('cbc')\n    solver.solve(m)\n    \n    return m\n\n\nm = chip_shop(data)\nprint('objective value: %s' % pyo.value(m.OBJ))\nfor i in m.types:\n    print('%10s optimal production: %3s' % (i, pyo.value(m.x[i])))\n\nobjective value: 190.0\n     plain optimal production: 57.5\n   mexican optimal production: 50.0"
  },
  {
    "objectID": "nbs/20221130_modeling_tips/index.html",
    "href": "nbs/20221130_modeling_tips/index.html",
    "title": "Linear programming tricks",
    "section": "",
    "text": "2 Summary\nIn this post we saw a number of tricks to transform special models into a linear program and mentioned typical applications. We saw how to handle absolute values, minimax objectives, fractional objectives and range contraints.\n\n\n\n\n\n\nReferences\n\nBisschop, Johannes. 2006. AIMMS Optimization Modeling. Lulu. com.\n\nFootnotes\n\n\nTricks for integer programming models will be part of another blog post.↩︎"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html",
    "title": "Job shop scheduling",
    "section": "",
    "text": "Code\nimport pyomo.environ as pyo\nimport pyomo.gdp as gdp\nimport pandas as pd\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#optimal-vs.-empirical-schedules",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#optimal-vs.-empirical-schedules",
    "title": "Job shop scheduling",
    "section": "Optimal vs. empirical schedules",
    "text": "Optimal vs. empirical schedules\nIn order to see the benefit of mathematical optimization we proceed as follows:\n\nWe visualize and compute KPIs for certain empirical schedules.\nWe visualize and compute KPIs for optimal schedules with respect to different KPIs.\nWe determine an optimal solution for a given set of jobs and a given sets of machines."
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#example",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#example",
    "title": "Job shop scheduling",
    "section": "Example",
    "text": "Example\nIn our discussion we use the following example of jobs.\n\n\nCode\njobs = {\n    'A': {'release':2, 'duration': 5, 'due': 10},\n    'B': {'release':5, 'duration': 6, 'due': 21},\n    'C': {'release':4, 'duration': 8, 'due': 15},\n    'D': {'release':0, 'duration': 4, 'due': 10},\n    'E': {'release':0, 'duration': 2, 'due':  5},\n    'F': {'release':8, 'duration': 3, 'due': 15},\n    'G': {'release':9, 'duration': 2, 'due': 22}\n}\npd.DataFrame(jobs).T.rename(columns = {'release': 'release time', \n                                       'duration': 'duration in hours',\n                                      'due':'due time'})\n\n\n\n\n\n\n  \n    \n      \n      release time\n      duration in hours\n      due time\n    \n  \n  \n    \n      A\n      2\n      5\n      10\n    \n    \n      B\n      5\n      6\n      21\n    \n    \n      C\n      4\n      8\n      15\n    \n    \n      D\n      0\n      4\n      10\n    \n    \n      E\n      0\n      2\n      5\n    \n    \n      F\n      8\n      3\n      15\n    \n    \n      G\n      9\n      2\n      22"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#gantt-charts",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#gantt-charts",
    "title": "Job shop scheduling",
    "section": "GANTT charts",
    "text": "GANTT charts\nSchedules can be visualised using GANTT charts. In the next cells we define some helper functions, for example to plot a Gantt chart.\nAfterwards we consider empirical schedules, in particular we consider:\n\nFirst-In First-Out (FIFO)\nLast-In, First-Out (LIFO)\nShortest Processing Time First (SPT)\nEarliest Due Data (EDD)\n\n\n\nCode\n# copy and pasted from jeffrey !\ndef gantt(JOBS, SCHEDULE={}):\n    bw = 0.3\n    plt.figure(figsize=(12, 0.7*(len(JOBS.keys()))))\n    idx = 0\n    for j in sorted(JOBS.keys()):\n        x = JOBS[j]['release']\n        y = JOBS[j]['due']\n        plt.fill_between([x,y],[idx-bw,idx-bw],[idx+bw,idx+bw], color='cyan', alpha=0.6)\n        if j in SCHEDULE.keys():\n            x = SCHEDULE[j]['start']\n            y = SCHEDULE[j]['finish']\n            plt.fill_between([x,y],[idx-bw,idx-bw],[idx+bw,idx+bw], color='red', alpha=0.5)\n            plt.plot([x,y,y,x,x], [idx-bw,idx-bw,idx+bw,idx+bw,idx-bw],color='k')\n            plt.text((SCHEDULE[j]['start'] + SCHEDULE[j]['finish'])/2.0,idx,\n                'Job ' + j, color='white', weight='bold',\n                horizontalalignment='center', verticalalignment='center')\n        idx += 1\n\n    plt.ylim(-0.5, idx-0.5)\n    plt.title('Job Schedule')\n    plt.xlabel('Time')\n    plt.ylabel('Jobs')\n    plt.yticks(range(len(JOBS)), JOBS.keys())\n    plt.grid()\n    xlim = plt.xlim()\n    \n    if SCHEDULE:\n        for j in SCHEDULE.keys():\n            if 'machine' not in SCHEDULE[j].keys():\n                SCHEDULE[j]['machine'] = 1\n        MACHINES = sorted(set([SCHEDULE[j]['machine'] for j in SCHEDULE.keys()]))\n\n        plt.figure(figsize=(12, 0.7*len(MACHINES)))\n        for j in sorted(SCHEDULE.keys()):\n            idx = MACHINES.index(SCHEDULE[j]['machine'])\n            x = SCHEDULE[j]['start']\n            y = SCHEDULE[j]['finish']\n            plt.fill_between([x,y],[idx-bw,idx-bw],[idx+bw,idx+bw], color='red', alpha=0.5)\n            plt.plot([x,y,y,x,x], [idx-bw,idx-bw,idx+bw,idx+bw,idx-bw],color='k')\n            plt.text((SCHEDULE[j]['start'] + SCHEDULE[j]['finish'])/2.0,idx,\n                'Job ' + j, color='white', weight='bold',\n                horizontalalignment='center', verticalalignment='center')\n        plt.xlim(xlim)\n        plt.ylim(-0.5, len(MACHINES)-0.5)\n        plt.title('Machine Schedule')\n        plt.yticks(range(len(MACHINES)), MACHINES)\n        plt.ylabel('Machines')\n        plt.grid()\n\n\n\n\nCode\n# jeffrery's code !\ndef schedule(JOBS, order):\n    \"\"\"Schedule a dictionary of JOBS on a single machine in a specified order.\"\"\"\n    start = 0\n    finish = 0\n    SCHEDULE = {}\n    for job in order:\n        start = max(JOBS[job]['release'], finish)\n        finish = start + JOBS[job]['duration']\n        SCHEDULE[job] = {'start': start, 'finish': finish}\n    return SCHEDULE\n\n\n\n\nCode\n# mainly jeffrery's code !\ndef schedule_from_model(m, machines = 1):\n    SCHEDULE = {}\n    for j in m.jobs:\n        if machines == 1:\n            tmp = 1\n        else:\n            tmp = [mach for mach in machines if pyo.value(m.job_to_machine[j,mach]) == 1][0]\n        SCHEDULE[j] = {\n            'start': m.start[j](), \n            'finish': m.start[j]() + m.duration[j],\n            'machine': tmp\n        }\n    return SCHEDULE\n\n\n\n\nCode\n# jeffreys code\n## KPI for job schedule\ndef kpi(JOBS, SCHEDULE):\n    KPI = {}\n    KPI['Makespan'] = max(SCHEDULE[job]['finish'] for job in SCHEDULE)\n    KPI['Max Pastdue'] = max(max(0, SCHEDULE[job]['finish'] - JOBS[job]['due']) for job in SCHEDULE)\n    KPI['Sum of Pastdue'] = sum(max(0, SCHEDULE[job]['finish'] - JOBS[job]['due']) for job in SCHEDULE)\n    KPI['Number Pastdue'] = sum(SCHEDULE[job]['finish'] > JOBS[job]['due'] for job in SCHEDULE)\n    KPI['Number on Time'] = sum(SCHEDULE[job]['finish'] <= JOBS[job]['due'] for job in SCHEDULE)\n    KPI['Fraction on Time'] = KPI['Number on Time']/len(SCHEDULE)\n    return KPI"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#a-manual-schedule",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#a-manual-schedule",
    "title": "Job shop scheduling",
    "section": "A Manual Schedule",
    "text": "A Manual Schedule\nBy specifying schedules we can evaluate and compare them. The following snippet shows how the user can specify a schedule and judge its performance through the KPIs.\nWe invite the reader to spend some minutes trying to find a better schedule. Spoiler: The given schedule here is already optimal in a way we will see later.\n\n\nCode\n# define schedule\njob_order = ['E','A','D','F','B','G','C']\n\n# visualize schedule\nSCHEDULE = schedule(jobs, order=job_order)\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 30,\n 'Max Pastdue': 15,\n 'Sum of Pastdue': 16,\n 'Number Pastdue': 2,\n 'Number on Time': 5,\n 'Fraction on Time': 0.7142857142857143}"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#alphabetic-schedule",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#alphabetic-schedule",
    "title": "Job shop scheduling",
    "section": "Alphabetic schedule",
    "text": "Alphabetic schedule\nLets assume the schedule is given by the names of the Jobs. This chould represent a case in which the schedule is predefined through its names by a human or by previous processes.\n\n\nCode\nSCHEDULE = schedule(jobs, order=sorted(jobs.keys()))\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 32,\n 'Max Pastdue': 22,\n 'Sum of Pastdue': 68,\n 'Number Pastdue': 5,\n 'Number on Time': 2,\n 'Fraction on Time': 0.2857142857142857}"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#fifo---first-in-first-out",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#fifo---first-in-first-out",
    "title": "Job shop scheduling",
    "section": "FIFO - first in first out",
    "text": "FIFO - first in first out\nWe evaluate a schedule, in which the ordering is defined by the release time of the job, i.e. what comes first is done first.\n\n\nCode\ndef fifo(JOBS):\n    order_by_release = sorted(JOBS, key=lambda job: JOBS[job]['release'])\n    return schedule(JOBS, order_by_release)\n\ngantt(jobs, fifo(jobs))\nkpi(jobs, fifo(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 13,\n 'Sum of Pastdue': 31,\n 'Number Pastdue': 6,\n 'Number on Time': 1,\n 'Fraction on Time': 0.14285714285714285}"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#lifo---last-in-first-out",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#lifo---last-in-first-out",
    "title": "Job shop scheduling",
    "section": "LIFO - last in first out",
    "text": "LIFO - last in first out\nWe put the jobs on a stack as follows: At time \\(t\\) we put all jobs with release time equal to \\(t\\) on top of the stack. If the machine has a free capacity, we assign the job which is on top of the stack to the machine and remove the job from the stack.\n\n\nCode\ndef lifo(JOBS):\n    unfinished_jobs = set(JOBS.keys())\n    start = 0\n    while len(unfinished_jobs) > 0:\n        start = max(start, min(JOBS[job]['release'] for job in unfinished_jobs))\n        lifo = {job:JOBS[job]['release'] for job in unfinished_jobs if JOBS[job]['release'] <= start}\n        job = max(lifo, key=lifo.get)\n        finish = start + JOBS[job]['duration']\n        unfinished_jobs.remove(job)\n        SCHEDULE[job] = {'machine': 1, 'start': start, 'finish': finish}\n        start = finish\n    return SCHEDULE          \n    \ngantt(jobs, lifo(jobs))\nkpi(jobs, lifo(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 20,\n 'Sum of Pastdue': 34,\n 'Number Pastdue': 3,\n 'Number on Time': 4,\n 'Fraction on Time': 0.5714285714285714}"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#spt---shortest-processing-time",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#spt---shortest-processing-time",
    "title": "Job shop scheduling",
    "section": "SPT - shortest processing time",
    "text": "SPT - shortest processing time\nShortest processing time (SPT) is a scheduling policy that selects for execution the waiting job with the smallest execution time.\n\n\nCode\ndef spt(JOBS):\n    unfinished_jobs = set(JOBS.keys())\n    start = 0\n    while len(unfinished_jobs) > 0:\n        start = max(start, min(JOBS[job]['release'] for job in unfinished_jobs))\n        spt = {job:JOBS[job]['duration'] for job in unfinished_jobs if JOBS[job]['release'] <= start}\n        job = min(spt, key=spt.get)\n        finish = start + JOBS[job]['duration']\n        unfinished_jobs.remove(job)\n        SCHEDULE[job] = {'machine': 1, 'start': start, 'finish': finish}\n        start = finish\n    return SCHEDULE          \n    \ngantt(jobs, spt(jobs))\nkpi(jobs, spt(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 15,\n 'Sum of Pastdue': 18,\n 'Number Pastdue': 4,\n 'Number on Time': 3,\n 'Fraction on Time': 0.42857142857142855}"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#edd---earliest-due-date",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#edd---earliest-due-date",
    "title": "Job shop scheduling",
    "section": "EDD - earliest due date",
    "text": "EDD - earliest due date\nEarliest due date (EDD) is a dynamic priority scheduling algorithm used in real-time operating systems to place processes in a priority queue. Whenever a scheduling event occurs (task finishes, new task released, etc.) the queue will be searched for the process closest to its deadline.\n\n\nCode\ndef edd(JOBS):\n    unfinished_jobs = set(JOBS.keys())\n    start = 0\n    while len(unfinished_jobs) > 0:\n        start = max(start, min(JOBS[job]['release'] for job in unfinished_jobs))\n        edd = {job:JOBS[job]['due'] for job in unfinished_jobs if JOBS[job]['release'] <= start}\n        job = min(edd, key=edd.get)\n        finish = start + JOBS[job]['duration']\n        unfinished_jobs.remove(job)\n        SCHEDULE[job] = {'machine': 1, 'start': start, 'finish': finish}\n        start = finish\n    return SCHEDULE          \n    \ngantt(jobs, edd(jobs))\nkpi(jobs, edd(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 8,\n 'Sum of Pastdue': 27,\n 'Number Pastdue': 5,\n 'Number on Time': 2,\n 'Fraction on Time': 0.2857142857142857}"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#modeling",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#modeling",
    "title": "Job shop scheduling",
    "section": "Modeling",
    "text": "Modeling\nWe give a algebraic representation of the model.\n\nSets\n\n\\(J\\) set of unique job IDs \\(j\\)\n\\(order:= \\{(i,j)~|~i,j\\in J\\}\\) - used to define weather job \\(j\\) is executed before job \\(i\\) or not\n\n\n\nParameter\n\n\\(due_j\\) due time of job \\(j\\)\n\\(duration_j\\) duration of job \\(j\\)\n\\(release_j\\) time job \\(j\\) becomes available for processing\n\n\n\nDecision variables\n\n\\(start_j\\) start of job \\(j\\)\n\n\n\nState variables\n\n\\(finished_j\\) time by which job \\(j\\) finishes\n\\(pastdue_j\\) time by which job \\(j\\) is past due\n\\(early_j\\) time by which job \\(j\\) is finished early\n\n\n\nConstraints\n\njob can not start until it is released for processing\n\n\\[\nstart_j\\geq release_j\n\\]\n\nexpressing timeline and how time variables are related\n\n\\[\n\\begin{array}{rl}\nstart_j + duration_j + early_j &= due_j + pastdue_j \\\\\nearly_j & \\geq 0 \\\\\npastdue_j & \\geq 0\n\\end{array}\n\\]\n\ndefinition of the objective makespan\n\n\\[\nfinish_j \\leq makespan\n\\]\n\ndefinition of state variable finish_j\n\n\\[\nstart_j + duration_j = finish_j\n\\]\n\nNo pair of jobs operates on the same machine at the same time.\n\nThis can be easily express as a set of disjunctions as follows:\n\\[\n\\left[finish_i \\leq start_j \\right] \\vee \\left[finish_j \\leq start_i \\right], \\; \\forall i<j\n\\]\n\n\nObjective\nAs we have mentioned in the introduction the application and circumstances define what an optimal schedule is."
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#implementation",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#implementation",
    "title": "Job shop scheduling",
    "section": "Implementation",
    "text": "Implementation\nThe following implementation allows optimizing with respect to the following objectives: - makespan, i.e. the time to complete all jobs - sum_pastdue, i.e. sum of past due\n\n\nCode\ndef model_1_machine(jobs, optimize = \"makespan\"):\n    \n    m = pyo.ConcreteModel()\n    \n    # sets\n    m.jobs = pyo.Set(initialize = jobs.keys())\n    m.order = pyo.Set(initialize = m.jobs * m.jobs, dimen = 2, filter = lambda m,i,j : i < j)\n    \n    # parameters\n    @m.Param(m.jobs, doc = \"job due time\")\n    def due(m,i):\n        return jobs[i]['due']\n    @m.Param(m.jobs, doc = \"job duration time\")\n    def duration(m,i):\n        return jobs[i]['duration']\n    @m.Param(m.jobs, doc = \"job release time\")\n    def release(m,i):\n        return jobs[i]['release']\n    \n    # upper bound on decision variables, in this case we choose the worst case \n    max_time = sum(m.duration[i] for i in m.jobs) + max(m.release[i] for i in m.jobs)\n    \n    # decision variables\n    m.start = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0, max_time))\n    ## additional variables\n    m.finish = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0, max_time))\n    m.pastdue = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0, max_time))\n    m.early = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0,max_time))\n    \n    # addtional variables for objectives\n    m.makespan = pyo.Var(domain = pyo.NonNegativeReals, bounds = (0, max_time), doc = \"time until all jobs are done\")\n    m.maxpastdue = pyo.Var(domain = pyo.NonNegativeReals, bounds = (0,max_time), doc = \"time\")\n    m.ispastdue = pyo.Var(m.jobs, domain = pyo.Binary)\n    \n    # objective\n    if optimize == 'makespan':\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n    elif optimize == 'sum_pastdue':\n        m.OBJ = pyo.Objective(expr = sum([m.pastdue[i] for i in m.jobs]), sense = pyo.minimize)\n    else:\n        print('wrong value for parameter optimize. allowed are \"makespan\" or \"sum_pastdue\" optimize = makespan used instead.')\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n\n    # constraints\n    @m.Constraint(m.jobs)\n    def job_finish(m,i, doc = \"defines job time finish\"):\n        return m.finish[i] == m.start[i] + m.duration[i]\n    @m.Constraint(m.jobs, doc = \"release before start\")\n    def start_after_release(m,i):\n        return m.start[i] >= m.release[i]\n    @m.Constraint(m.jobs, doc =\"describe position of job w.r.t. time in schedule\")\n    def time_relations(m,i):\n        return m.start[i] + m.duration[i] + m.early[i] == m.due[i] + m.pastdue[i]\n    @m.Constraint(m.jobs, doc = \"finish time lower than make span\")\n    def finish_lower_makespan(m,i):\n        return m.finish[i] <= m.makespan\n    \n    m.schedule = gdp.Disjunction(m.order, rule = lambda m,i,j:\n                                [m.finish[i] <= m.start[j],\n                                 m.finish[j] <= m.start[i]])\n    \n    @m.Constraint(m.jobs, doc = \"past due lower than max past due\")\n    def pastdue_lower_maxpastdue(m,i):\n        return m.pastdue[i] <= m.maxpastdue\n    @m.Constraint(m.jobs, doc =\"\")\n    def pastdue_lower_max_time(m,i):\n        return m.pastdue[i] <= max_time * m.ispastdue[i]\n    pyo.TransformationFactory('gdp.hull').apply_to(m)\n    pyo.SolverFactory('glpk').solve(m)#.write()\n    \n    return m\n\n\n\nOptimal makespan\nBy defintion makespan is the time to complete all jobs.\n\n\nCode\nmodel = model_1_machine(jobs, optimize = \"makespan\")\nSCHEDULE = schedule_from_model(model)\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 30.0,\n 'Max Pastdue': 11.0,\n 'Sum of Pastdue': 29.0,\n 'Number Pastdue': 3,\n 'Number on Time': 4,\n 'Fraction on Time': 0.5714285714285714}"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#modeling-1",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#modeling-1",
    "title": "Job shop scheduling",
    "section": "Modeling",
    "text": "Modeling\nThe algebraic representation of the model is the following:"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#sets-1",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#sets-1",
    "title": "Job shop scheduling",
    "section": "Sets",
    "text": "Sets\n\n\\(machines\\) - elements are abbreviated with \\(m\\)\n\\(jobs\\) - elements are abbreviated with \\(j\\) or \\(i\\)\n\\(order:= jobs \\times jobs\\) - schedule order of jobs"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#parameters",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#parameters",
    "title": "Job shop scheduling",
    "section": "Parameters",
    "text": "Parameters\n\n\\(release_j\\)\n\\(duration_j\\)\n\\(due_j\\)\n\\(BigM\\) - big M integer in modeling the disjunctions"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#variables",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#variables",
    "title": "Job shop scheduling",
    "section": "Variables",
    "text": "Variables\n\nDecision variables\n\n\\(start_i\\) - time job \\(i\\) starts\n\\(job\\_to\\_machine_{j,m}\\) - binary variable, 1 iff job \\(j\\) is assigned to machine \\(m\\)\n\n\n\nState variables\n\n\\(pastdue_i\\) - time job \\(i\\) is past due\n\\(early_i\\) - time job \\(i\\) is finished early\n\n\n\nAssignment to machines\n\n\\(job\\_to\\_machine_{j,m}\\) - binary assingment of jobs to machine; \\(job\\_to\\_machine_{j,m}==1\\) iff job \\(j\\) is executed on \\(m\\)\n\n\n\nObjective vars\n\nmakespan - non negative real\nispastdue - binary, 1 iff job finish past due\nmaxpastdue - non negative real\n\n\n\nConstraints\nBecause the following model should work for different objective functions some constraints might be unused for a given objective function, but we believe it is easy to identify them.\n\\[\n\\begin{array}{llc}\n  start_j \\geq release_j & \\;\\forall j\\in jobs & c_1\\\\\n  start_j + duration_j + early_j = due_j + pastdue_j & \\;\\forall j\\in jobs &c_2\\\\\n  [early_j==0] \\vee [pastdue_j == 0] & \\;\\forall j\\in jobs & d_1\\\\\n  [pastdue_j == 0] \\vee [ispastdue_j == 1] & \\;\\forall j\\in jobs & d_2\\\\\n  \\sum_m jobs\\_to\\_machine_{j,m} = 1 & \\;\\forall j\\in jobs, \\forall m \\in machines & c_3\\\\\n  pastdue_j <= maxpastdue & \\;\\forall j\\in jobs & c_4\\\\\n  start_j + duration_j <= makespan & \\;\\forall j\\in jobs & c_5\\\\\n  [T1] \\vee_{i,j,m} [T2] & \\;\\forall i,j \\in order, \\forall m \\in machines & d_3\n\\end{array}\n\\]\nwhere \\[\n\\begin{array}{c}\nT1 := start_i + duration_i \\leq start_j + M(1-jobs\\_to\\_machine_{i,m}) +  M(1-jobs\\_to\\_machine_{j,m})\\\\\nT2 := start_j + duration_j \\leq start_i + M(1-jobs\\_to\\_machine_{i,m}) +  M(1-jobs\\_to\\_machine_{j,m})\n\\end{array}\n\\]\n\n\nConstraints explaination\n\n\\(c_1\\) job starts after its release\n\\(c_2\\) relation among time variables - required because not all jobs may finish before their due time\n\\(d_1\\) job is either early or pastdue\n\\(d_2\\) definition of objective variable ispastdue\n\\(c_3\\) each job is assign to one and only one machine\n\\(c_4\\) definition of objective variable maxpastdue\n\\(c_5\\) definition of objective variable makespan\n\\(d_3\\) job \\(j\\) does not start before previous job \\(i\\) has finished on machine \\(m\\)"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#example-scheduling-multiple-machines",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#example-scheduling-multiple-machines",
    "title": "Job shop scheduling",
    "section": "Example scheduling multiple machines",
    "text": "Example scheduling multiple machines\nWe consider two machines which should perform the following jobs:\n\n\nCode\nmachines = ['1','2']\njobs = {\n    'A': {'release':2, 'duration': 5, 'due': 10},\n    'B': {'release':5, 'duration': 6, 'due': 21},\n    'C': {'release':4, 'duration': 8, 'due': 15},\n    'D': {'release':0, 'duration': 4, 'due': 10},\n    'E': {'release':0, 'duration': 2, 'due':  5},\n    'F': {'release':8, 'duration': 3, 'due': 15},\n    'G': {'release':9, 'duration': 2, 'due': 22}\n}\n\n\n\n\nCode\ndef model_multiple_machines(jobs, machines, optimize = 'makespan'):\n    #instanciate model\n    m = pyo.ConcreteModel(\"multiple jobs, multiple workers\")\n    \n    # index sets\n    m.jobs = pyo.Set(initialize = jobs.keys())\n    m.machines = pyo.Set(initialize = machines)\n    m.order = pyo.Set(initialize = m.jobs * m.jobs, dimen = 2, filter = lambda m,i,j: i<j)\n    \n    # parameters\n    @m.Param(m.jobs, doc = \"job due time\")\n    def due(m,i):\n        return jobs[i]['due']\n    @m.Param(m.jobs, doc = \"job duration time\")\n    def duration(m,i):\n        return jobs[i]['duration']\n    @m.Param(m.jobs, doc = \"job release time\")\n    def release(m,i):\n        return jobs[i]['release']\n    # doc = \"big M integer in modeling disjunctions\" and apply hull transform\n    BigM = max([m.release[j] for j in m.jobs]) + sum([m.duration[j] for j in m.jobs])\n    \n    # variables\n    ## decision / timeline variables\n    m.start = pyo.Var(m.jobs, domain = pyo.NonNegativeReals,\n                      bounds = (0, 1000) ,\n                      doc = \"start time of job\")\n    m.pastdue = pyo.Var(m.jobs, domain = pyo.NonNegativeReals,\n                        bounds = (0, 1000),\n                        doc = \"time job is past due\")\n    m.early = pyo.Var(m.jobs, domain = pyo.NonNegativeReals,\n                      bounds = (0, 10000),\n                      doc = \"time job is finished early\")\n    \n    ## objective variables\n    m.makespan = pyo.Var(domain = pyo.NonNegativeReals, doc = \"time to complete all jobs\")\n    m.ispastdue = pyo.Var(m.jobs, domain = pyo.Binary, doc = \"binary iff job is overdue\")\n    m.maxpastdue = pyo.Var(domain = pyo.NonNegativeReals, doc = \"\")\n    \n    ## additional variales\n    m.job_to_machine = pyo.Var(m.jobs, m.machines, domain = pyo.Binary, doc = \"binary assignment job to machine\")\n    \n    # objective\n    if optimize == 'makespan':\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n    elif optimize == 'sum_pastdue':\n        m.OBJ = pyo.Objective(expr = sum([m.pastdue[i] for i in m.jobs]), sense = pyo.minimize)\n    else:\n        print('wrong value for parameter optimize. allowed are \"makespan\" or \"sum_pastdue\" optimize = makespan used instead.')\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n\n    # constraint / disjunctions\n    @m.Constraint(m.jobs, doc = \"job start after release\")\n    def c1(m,i):\n        return m.start[i] >= m.release[i]\n    \n    @m.Constraint(m.jobs, doc = \"time variable relation\")\n    def c2(m,i):\n        return m.start[i] + m.duration[i] + m.early[i] == m.due[i] + m.pastdue[i]\n    \n    @m.Disjunction(m.jobs, doc = \"job either early or pastdue\")\n    def d1(m,i):\n        return [m.early[i]==0, m.pastdue[i]==0]\n    \n    @m.Disjunction(m.jobs, doc = \"\")\n    def d2(m,j):\n        return [m.pastdue[j] == 0, m.ispastdue[j] == 1],\n    \n    @m.Constraint(m.jobs, doc = \"each job is assigned to one and only one machine\")\n    def c3(m,j):\n        return (sum(m.job_to_machine[j,machine] for machine in m.machines) == 1)\n    \n    @m.Constraint(m.jobs, doc = \"define objective variable maxpastdue\")\n    def  c4(m,j):\n        return m.pastdue[j] <= m.maxpastdue\n    \n    @m.Constraint(m.jobs, doc = \"define objective variable makespan\")\n    def c6(m,i):\n        return m.start[i] + m.duration[i] <= m.makespan\n    \n    @m.Disjunction(m.machines, m.order, doc = \"ordering of jobs\")\n    def d3(m, machine, i,j):\n        return [m.start[i] + m.duration[i] <= m.start[j] + BigM * ((1 - m.job_to_machine[i,machine]) + (1 - m.job_to_machine[j,machine])),\n                m.start[j] + m.duration[j] <= m.start[i] + BigM * ((1 - m.job_to_machine[i,machine]) + (1 - m.job_to_machine[j,machine]))\n               ]\n    transform = pyo.TransformationFactory('gdp.hull')\n    transform.apply_to(m)\n    # solve model\n    pyo.SolverFactory('glpk').solve(m)\n    return m"
  },
  {
    "objectID": "nbs/20220621_jobshop/00_bottleneck_machine.html#optimal-makespan---multiple-machines",
    "href": "nbs/20220621_jobshop/00_bottleneck_machine.html#optimal-makespan---multiple-machines",
    "title": "Job shop scheduling",
    "section": "Optimal makespan - multiple machines",
    "text": "Optimal makespan - multiple machines\n\n\nCode\nmodel = model_multiple_machines(jobs, machines, optimize = 'makespan')\nSCHEDULE = schedule_from_model(model, machines)\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 15.0,\n 'Max Pastdue': 0,\n 'Sum of Pastdue': 0,\n 'Number Pastdue': 0,\n 'Number on Time': 7,\n 'Fraction on Time': 1.0}"
  },
  {
    "objectID": "nbs/20220609_blending_models/01_blending.html",
    "href": "nbs/20220609_blending_models/01_blending.html",
    "title": "Blending models - Steel production",
    "section": "",
    "text": "In blending or product mix problems, one tries to mix or extract ingredients subject to quality constraints.\nWe start with the following easy example in which we have one product and different raw materials. This example is taken from (Guéret, Prins, and Sevaux 1999, chap. 6.1).\n\n\nWe want to produce a predefined quantity of a product, e.g. steel. The produced product must have certain characteristics (grades) - see section below. In stock we have different possible ingredients, e.g. ores, and these ingredients contribute differently to the requirements and have different availablility and prices - see section below.\nWe want to determine the recipie which minimizes the production costs.\n\n\nCode\nimport pandas as pd\nimport pyomo.environ as pyo"
  },
  {
    "objectID": "nbs/20220609_blending_models/01_blending.html#sets",
    "href": "nbs/20220609_blending_models/01_blending.html#sets",
    "title": "Blending models - Steel production",
    "section": "sets",
    "text": "sets\n\n\\(raw\\) - set of raw materials\n\\(comp\\) - set of grade requirements"
  },
  {
    "objectID": "nbs/20220609_blending_models/01_blending.html#variables",
    "href": "nbs/20220609_blending_models/01_blending.html#variables",
    "title": "Blending models - Steel production",
    "section": "variables",
    "text": "variables\n\n\\(use_r\\) - used quantity in optimal recipie of raw material \\(r\\)"
  },
  {
    "objectID": "nbs/20220609_blending_models/01_blending.html#parameter",
    "href": "nbs/20220609_blending_models/01_blending.html#parameter",
    "title": "Blending models - Steel production",
    "section": "parameter",
    "text": "parameter\n\n\\(demand\\) - demand of the product\n\\(produce\\) - produced quatity of the product\n\\(cost_r\\) - costs of raw material \\(r\\)\n\\(P_{rc}\\) - percentage of component \\(c\\) in raw material \\(r\\)\n\\(Pmin_c\\) - minimal requirement of component \\(c\\) in product\n\\(Pmax_c\\) - maximal requirement of component \\(c\\) in product"
  },
  {
    "objectID": "nbs/20220609_blending_models/01_blending.html#objective",
    "href": "nbs/20220609_blending_models/01_blending.html#objective",
    "title": "Blending models - Steel production",
    "section": "objective",
    "text": "objective\n\nfind the recipe with minimal costs fulfilling the requirements"
  },
  {
    "objectID": "nbs/20220609_blending_models/01_blending.html#constraints",
    "href": "nbs/20220609_blending_models/01_blending.html#constraints",
    "title": "Blending models - Steel production",
    "section": "constraints",
    "text": "constraints\n\n(c1) produced quatity is given by the sum of the used rat materials (in tons)\n(c2) lower limit on the components in the final product\n(c3) upper limit on the components in the final product\n(c4) use only available quatities of the raw materials\n(c5) produced quatity fulfills demands"
  },
  {
    "objectID": "nbs/20220609_blending_models/01_blending.html#deterministic-model",
    "href": "nbs/20220609_blending_models/01_blending.html#deterministic-model",
    "title": "Blending models - Steel production",
    "section": "deterministic model",
    "text": "deterministic model\n\\[\n\\begin{array}{llll}\n\\min & \\sum_{r\\in raw} cost_r \\cdot use_r & & \\\\\ns.t. & produce = \\sum_{r\\in raw} use_r & & (c1)\\\\\n     & \\sum_{r\\in raw} P_{rc}\\cdot use_r \\geq Pmin_c \\cdot produce & , \\forall c\\in comp & (c2)\\\\\n     & \\sum_{r\\in raw} P_{rc}\\cdot use_r \\leq Pmax_c \\cdot produce &  , \\forall c\\in comp & (c3)\\\\\n     & use_r \\leq avail_r &  , \\forall r\\in raw & (c4) \\\\\n     & produce \\geq demand & & (c5) \\\\\n     & use_r,produce \\geq 0 & & (c6)\n\\end{array}\n\\]\n\n\nCode\ndef alloy_blending(requirements,raw_mat, demand):\n    m = pyo.ConcreteModel('alloy production')\n    \n    # sets\n    m.raw = pyo.Set(initialize = raw_mat.raw_mat)\n    m.comp = pyo.Set(initialize = requirements.element)\n    \n    # parameter\n    @m.Param(m.raw, doc = 'costs of raw mat r')\n    def costs(m,r):\n        return raw_mat.loc[raw_mat['raw_mat'] == r, 'costs'].values[0]\n    @m.Param(m.raw, m.comp, doc = 'percentage of component c in raw material r')\n    def P(m,r,c):\n        return raw_mat.loc[raw_mat['raw_mat'] == r, c].values[0]\n    @m.Param(m.comp, doc= 'minimal percentage of component c in final product')\n    def Pmin(m,c):\n        return requirements.loc[requirements['element'] == c, 'min_grade'].values[0]\n    @m.Param(m.comp, doc= 'maximal percentage of component c in final product')\n    def Pmax(m,c):\n        return requirements.loc[requirements['element'] == c, 'max_grade'].values[0]\n    @m.Param(m.raw, doc = 'availability of raw materials')\n    def avail(m,r):\n        return raw_mat.loc[raw_mat['raw_mat'] == r, 'availability'].values[0]\n    @m.Param(doc = 'product demand')\n    def demand(m):\n        return demand\n    \n    # variables\n    m.use = pyo.Var(m.raw, domain = pyo.NonNegativeReals, doc = 'used tons of raw material r')\n    m.produced = pyo.Var(domain = pyo.NonNegativeReals, doc = 'tons produced')\n    \n    # objective\n    def objective(m):\n        return pyo.summation(m.costs, m.use)\n    m.OBJ = pyo.Objective(rule = objective(m), sense = pyo.minimize)\n    \n    # constraints\n    @m.Constraint(doc ='tons produced')\n    def c1(m):\n        return m.produced == pyo.summation(m.use)\n    \n    @m.Constraint(m.comp, doc = 'lower limit of grade in final product')\n    def c2(m, c):\n        return sum(m.P[r,c] * m.use[r] for r in m.raw) >= m.Pmin[c] * m.produced\n    @m.Constraint(m.comp, doc = 'upper limit of grade in final product')\n    def c3(m, c):\n        return sum(m.P[r,c] * m.use[r] for r in m.raw) <= m.Pmax[c] * m.produced\n    @m.Constraint(m.raw, doc = 'use component c maximal w.r.t. availability of c')\n    def c4(m, r):\n        return m.use[r] <= m.avail[r]\n    @m.Constraint(doc = 'produce at least the demand')\n    def c5(m):\n        return m.produced >= m.demand\n\n    \n    # solver\n    solver = pyo.SolverFactory('glpk')\n    solver.solve(m)\n    \n    return m"
  },
  {
    "objectID": "nbs/20220609_blending_models/02_food_production.html",
    "href": "nbs/20220609_blending_models/02_food_production.html",
    "title": "Blending models - Food production",
    "section": "",
    "text": "In blending or product mix problems, one tries to mix or extract ingredients subject to quality constraints.\nIn the following example we have multiple products, differnt raw materials and the products have different production steps."
  },
  {
    "objectID": "nbs/20220609_blending_models/02_food_production.html#sets",
    "href": "nbs/20220609_blending_models/02_food_production.html#sets",
    "title": "Blending models - Food production",
    "section": "sets",
    "text": "sets\n\n\\(raw\\) - set of raw materials\n\\(food\\) - set of products\n\\(comp\\) - set of nutritional components\n\\(prod\\_steps\\) - set of production steps"
  },
  {
    "objectID": "nbs/20220609_blending_models/02_food_production.html#variables",
    "href": "nbs/20220609_blending_models/02_food_production.html#variables",
    "title": "Blending models - Food production",
    "section": "variables",
    "text": "variables\n\n\\(use_{rf}\\) - used quantity of raw material \\(r\\) for food \\(f\\)\n\\(produced_f\\) - produced quantity of food \\(f\\)"
  },
  {
    "objectID": "nbs/20220609_blending_models/02_food_production.html#parameter",
    "href": "nbs/20220609_blending_models/02_food_production.html#parameter",
    "title": "Blending models - Food production",
    "section": "parameter",
    "text": "parameter\n\n\\(cost_r\\) - costs of raw material \\(r\\)\n\\(pcosts\\) - costs per production process \\(p\\)\n\\(minreq_c\\) - minimal requirement of component \\(c\\)\n\\(maxreq_c\\) - maximal requirement of component \\(c\\)\n\\(content_{rc}\\) - content of component \\(c\\) in raw material \\(r\\)\n\\(avail_r\\) - maximal available quantity of raw material \\(r\\)\n\\(demand_f\\) - daily demand of food product \\(f\\)"
  },
  {
    "objectID": "nbs/20220609_blending_models/02_food_production.html#objective",
    "href": "nbs/20220609_blending_models/02_food_production.html#objective",
    "title": "Blending models - Food production",
    "section": "objective",
    "text": "objective\n\nminimize the sum of all cost, whild fulfilling demand and requirements"
  },
  {
    "objectID": "nbs/20220609_blending_models/02_food_production.html#constraints",
    "href": "nbs/20220609_blending_models/02_food_production.html#constraints",
    "title": "Blending models - Food production",
    "section": "constraints",
    "text": "constraints\n\n\\((c0)\\) define the produced quantity of food \\(f\\)\n\\((c1)\\) produce food \\(f\\) is at least as high as the demand for \\(f\\)\n\\((c2)\\) amount of used raw material \\(r\\) can not exceed its availability\n\\((c3)\\) product \\(f\\) fulfill contain at least minimal amount of component \\(c\\)\n\\((c4)\\) product \\(f\\) fulfill contain at most maximal amount of component \\(c\\)"
  },
  {
    "objectID": "nbs/20220609_blending_models/02_food_production.html#deterministic-model",
    "href": "nbs/20220609_blending_models/02_food_production.html#deterministic-model",
    "title": "Blending models - Food production",
    "section": "deterministic model",
    "text": "deterministic model\nThe optimization problem above is described by the following linear program:\n\\[\n\\begin{array}{llll}\n\\min & \\sum_{r,f}cost_r * use_{r,f} & & \\\\\ns.t. & produced_f := \\sum_r use_{rf}& \\forall f & (c0)\\\\\n     & produced_f \\leq demand_f     & \\forall f & (c1)\\\\\n     & \\sum_f use_{rf} \\leq avil_r  & \\forall r & (c2)\\\\\n     & \\sum_r use_r * content_{rc} \\geq minreq_c * produced_f & \\forall f,c & (c3)\\\\\n     & \\sum_r use_r * content_{rc} \\leq maxreq_c * produced_f & \\forall f,c & (c4)\\\\\n\\end{array}\n\\]\n\n\nCode\ndef animal_food(data):\n    m = pyo.ConcreteModel()\n    \n    # sets\n    m.raw = pyo.Set(initialize = data['raw_mat'].keys(), doc = \"raw materials r\")\n    m.food = pyo.Set(initialize = data['demand'].keys(), doc = \"products f\")\n    m.prod_steps = pyo.Set(initialize = data['prod_cost'].keys(), doc = 'production step ps')\n    m.comp = pyo.Set(initialize = data['requirements'].keys(), doc = 'required components')\n    \n    # vars\n    m.use = pyo.Var(m.raw, m.food, domain = pyo.NonNegativeReals, doc = \"quantity of raw mat r used for product f\")\n    m.produced = pyo.Var(m.food, domain = pyo.NonNegativeReals, doc = \"produced quantity of food f\")\n    # vars for output\n    m.food_comp = pyo.Var(m.food, m.comp, domain = pyo.NonNegativeReals, doc = \"percentage of component c in  final product f\")\n    \n    # param\n    @m.Param(m.food, doc = \"demand for food f\")\n    def demand(m,f):\n        return data['demand'][f]\n    @m.Param(m.raw, doc = \"available quantity of raw mat r\")\n    def avail(m,r):\n        return data['raw_mat'][r]['availability']\n    @m.Param(m.raw, doc = 'cost of raw material r')\n    def cost(m,r):\n        return data['raw_mat'][r]['costs']\n    @m.Param(m.prod_steps, doc = 'cost production step ps')\n    def pcost(m,ps):\n        return data['prod_cost'][ps]\n    @m.Param(m.raw, m.comp)\n    def content(m,r,c):\n        return data['raw_mat'][r][c]\n    @m.Param(m.comp, doc = 'minimal requirement per component c')\n    def minreq(m,c):\n        return data['requirements'][c]['min_content']\n    \n    # Objective\n    m.mat_cost = pyo.quicksum(m.cost[r] * m.use[r,f] for r in m.raw for f in m.food)\n    m.grinding_cost = pyo.quicksum(m.pcost['grinding'] * m.use[r,f] for r in m.raw for f in m.food if f != 'Molasses')\n    m.blending_cost = pyo.quicksum(m.pcost['blending'] * m.use[r,f] for r in m.raw for f in m.food)\n    m.granul_cost = pyo.quicksum(m.pcost['granulating'] * m.use[r,'granule'] for r in m.raw)\n    m.siev_cost = pyo.quicksum(m.pcost['sieving'] * m.use[r,'powder'] for r in m.raw)\n    \n    m.OBJ = pyo.Objective(expr = m.mat_cost + \n                          m.grinding_cost +\n                          m.blending_cost + \n                          m.granul_cost + \n                          m.siev_cost,\n                          sense= pyo.minimize)\n    \n    \n    # constraints\n    @m.Constraint(m.food, doc = \"definition of produced\")\n    def c0(m,f):\n        return pyo.quicksum(m.use[r,f] for r in m.raw) == m.produced[f]\n    @m.Constraint(m.food, doc = \"fulfill demand\")\n    def c1(m,f):\n        return m.produced[f] >= m.demand[f]\n    @m.Constraint(m.raw, doc = \"dont use more than available\")\n    def c2(m,r):\n        return pyo.quicksum(m.use[r,f] for f in m.food) <= m.avail[r]\n    @m.Constraint(m.food, m.comp, doc = \"minimal reuirement fulfilled\")\n    def c3(m,f,c):\n        return pyo.quicksum(m.content[r,c] * m.use[r,f] for r in m.raw) >= m.minreq[c] * m.produced[f]\n    \n    m.c4 = pyo.ConstraintList(doc = \"fulfill maximal requirement\")\n    for f in m.food:\n        for c in m.comp:\n            x = data['requirements'][c]['max_content']\n            if ~np.isnan(x):\n                m.c4.add(pyo.quicksum(m.use[r,f] * m.content[r,c,] for r in m.raw) <= x * m.produced[f])\n            \n    @m.Constraint(m.food, m.comp,\n                  doc = 'defintion of component c in final product f')\n    def c5(m,f,c):\n        return pyo.quicksum(m.use[r,f] * m.content[r,c,] for r in m.raw) == m.food_comp[f,c]\n    \n    \n    solver = pyo.SolverFactory('glpk')\n    solver.solve(m)\n    \n    return m"
  },
  {
    "objectID": "nbs/20221127_jupyter_test/index.html",
    "href": "nbs/20221127_jupyter_test/index.html",
    "title": "Pyomo and solver test",
    "section": "",
    "text": "We give the implementation of a simple model in pyomo to test the correct installation and in particular the solvers.\nExpectation: code is executed without errors\n\n\nconda env create -f environment.yml\nconda activate blog\n\nimport pyomo.environ as pyo\n\n\nmodel = pyo.ConcreteModel()\n\nmodel.x = pyo.Var([1,2], domain=pyo.NonNegativeReals)\n\nmodel.OBJ = pyo.Objective(expr = 2*model.x[1] + 3*model.x[2])\n\nmodel.Constraint1 = pyo.Constraint(expr = 3*model.x[1] + 4*model.x[2] >= 1)\n\n\nglpk_test = pyo.SolverFactory('glpk')\ncbc_test = pyo.SolverFactory('cbc')\nipopt_test = pyo.SolverFactory('ipopt')\n\n\nglpk_test.solve(model)\n\n{'Problem': [{'Name': 'unknown', 'Lower bound': 0.666666666666667, 'Upper bound': 0.666666666666667, 'Number of objectives': 1, 'Number of constraints': 2, 'Number of variables': 3, 'Number of nonzeros': 3, 'Sense': 'minimize'}], 'Solver': [{'Status': 'ok', 'Termination condition': 'optimal', 'Statistics': {'Branch and bound': {'Number of bounded subproblems': 0, 'Number of created subproblems': 0}}, 'Error rc': 0, 'Time': 0.013138532638549805}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value             : Upper : Fixed : Stale : Domain\n          1 :     0 : 0.333333333333333 :  None : False : False : NonNegativeReals\n          2 :     0 :               0.0 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1\n\n\n\ncbc_test.solve(model)\n\n{'Problem': [{'Name': 'unknown', 'Lower bound': 0.6666666667, 'Upper bound': 0.6666666667, 'Number of objectives': 1, 'Number of constraints': 2, 'Number of variables': 3, 'Number of nonzeros': 0, 'Sense': 'minimize'}], 'Solver': [{'Status': 'ok', 'User time': -1.0, 'System time': 0.0, 'Wallclock time': 0.0, 'Termination condition': 'optimal', 'Termination message': 'Model was solved to optimality (subject to tolerances), and an optimal solution is available.', 'Statistics': {'Branch and bound': {'Number of bounded subproblems': None, 'Number of created subproblems': None}, 'Black box': {'Number of iterations': 0}}, 'Error rc': 0, 'Time': 0.04025125503540039}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value      : Upper : Fixed : Stale : Domain\n          1 :     0 : 0.33333333 :  None : False : False : NonNegativeReals\n          2 :     0 :        0.0 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1\n\n\n\nipopt_test.solve(model)\n\n{'Problem': [{'Lower bound': -inf, 'Upper bound': inf, 'Number of objectives': 1, 'Number of constraints': 1, 'Number of variables': 2, 'Sense': 'unknown'}], 'Solver': [{'Status': 'ok', 'Message': 'Ipopt 3.14.11\\\\x3a Optimal Solution Found', 'Termination condition': 'optimal', 'Id': 0, 'Error rc': 0, 'Time': 0.05022311210632324}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value                   : Upper : Fixed : Stale : Domain\n          1 :     0 :      0.3333333343972087 :  None : False : False : NonNegativeReals\n          2 :     0 : -2.3599945501636825e-09 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1"
  },
  {
    "objectID": "nbs/20230308_scip/03_multicommodity_transportProblem.html",
    "href": "nbs/20230308_scip/03_multicommodity_transportProblem.html",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "",
    "text": "We generalize our transport problem to the case that we are producing multiple commodities in our factories. Again each factory has its own production capacity and the markets have their own demand for each commodity. Moreover the transport costs depends on the commodity.\n\n\n\njson file as data input"
  },
  {
    "objectID": "nbs/20230308_scip/03_multicommodity_transportProblem.html#sets",
    "href": "nbs/20230308_scip/03_multicommodity_transportProblem.html#sets",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "sets",
    "text": "sets\n\n\\(I\\) customer\n\\(J\\) factory\n\\(K\\) commodity"
  },
  {
    "objectID": "nbs/20230308_scip/03_multicommodity_transportProblem.html#variables",
    "href": "nbs/20230308_scip/03_multicommodity_transportProblem.html#variables",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "variables",
    "text": "variables\n\n\\(x_{i,j,k}\\) transported amount of commodity \\(k\\) form factory \\(j\\) to customer \\(i\\)"
  },
  {
    "objectID": "nbs/20230308_scip/03_multicommodity_transportProblem.html#parameters",
    "href": "nbs/20230308_scip/03_multicommodity_transportProblem.html#parameters",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "parameters",
    "text": "parameters\n\n\\(c_{i,j,k}\\) transport costs of commodity \\(k\\) form factory \\(j\\) to customer \\(i\\)\n\\(d_{i,k}\\) demand of commodity \\(k\\) in market \\(i\\)\n\\(M_j\\) capacity of factory \\(j\\)"
  },
  {
    "objectID": "nbs/20230308_scip/03_multicommodity_transportProblem.html#constraints",
    "href": "nbs/20230308_scip/03_multicommodity_transportProblem.html#constraints",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "constraints",
    "text": "constraints\n\n(c1) fulfill demand in each market\n(c2) do not exceed factory capacity"
  },
  {
    "objectID": "nbs/20230308_scip/03_multicommodity_transportProblem.html#objective",
    "href": "nbs/20230308_scip/03_multicommodity_transportProblem.html#objective",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "objective",
    "text": "objective\nMinimize total costs"
  },
  {
    "objectID": "nbs/20230308_scip/03_multicommodity_transportProblem.html#model",
    "href": "nbs/20230308_scip/03_multicommodity_transportProblem.html#model",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "model",
    "text": "model\n\\[\n\\begin{array}{lll}\n\\min & \\sum_{i,j,l} c_{i,j,k} x_{i,j,k} & \\\\\ns.t. & \\sum_j x_{i,j,k} = d_{i,k} & \\forall i,k \\\\\n     & \\sum_{i,k} x_{i,j,k} \\leq M_j & \\forall j \\\\\n     & x_{i,j,k} \\leq 0 &\n\\end{array}\n\\]\n\nimport pyscipopt as scip\nimport json\n\n\ndata = {\n    \"Name\": \"multi-commodity transportation\",\n    \n    \"Engine\": \"\",\n    \"TimeLimit\": \"\"\n\n}\n\n\n# data\nJ,M = scip.multidict({1:3000, 2:3000, 3:3000})\nproduce = {1:[2,4], 2:[1,2,3], 3:[2,3,4]}\n\nd = {(1,1):80,   (1,2):85,   (1,3):300,  (1,4):6,\n     (2,1):270,  (2,2):160,  (2,3):400,  (2,4):7,\n     (3,1):250,  (3,2):130,  (3,3):350,  (3,4):4,\n     (4,1):160,  (4,2):60,   (4,3):200,  (4,4):3,\n     (5,1):180,  (5,2):40,   (5,3):150,  (5,4):5\n     }\nI = set([i for (i,k) in d])\nK = set([k for (i,k) in d])\n\nweight = {1:5, 2:2, 3:3, 4:4}\ncost = {(1,1):4,  (1,2):6, (1,3):9,\n        (2,1):5,  (2,2):4, (2,3):7,\n        (3,1):6,  (3,2):3, (3,3):4,\n        (4,1):8,  (4,2):5, (4,3):3,\n        (5,1):10, (5,2):8, (5,3):4\n        }\nc = {}\nfor i in I:\n    for j in J:\n        for k in produce[j]:\n            c[i, j, k] = cost[i,j] * weight[k]\n\n\ndef MultiCommoditityTransportation(I,J,K, c,d,M):\n    \n    model = scip.Model()\n    # vars\n    x = {}\n    for i in I:\n        for j in J:\n            for k in K:\n                x[i,j,k] = model.addVar(vtype = 'C',\n                                       name = 'x(%s,%s,%s)' %  (i,j,k))\n                \n    # constraints\n    for j in J:\n        model.addCons(scip.quicksum(x[i,j,k] for (i,j_,k) in x if j_ == j) <= M[j],\n                      name = 'FactoryCapacity(%s)' % j)\n        \n    for i in I:\n        for k in K:\n            model.addCons(scip.quicksum(x[i,j,k] for j in J if (i,j,k) in x) == d[i,k]\n            )\n\n    # objective\n    model.setObjective(scip.quicksum(c[i,j,k] * x[i,j,k]  for (i,j,k) in c),\n                      sense = 'minimize')\n    \n    # for post processing\n    model.data = x\n    \n    return model\n\n\nm = MultiCommoditityTransportation(I,J,K, c,d,M)\nm.optimize()\n\n\nprint('optimal value:', m.getObjVal())\nepsilon =1.e-6\nx = m.data\nfor (i,j,k) in x:\n    if m.getVal(x[i,j,k]) >= epsilon:\n        print('send %10s of commodity %3s from factory %3s to customer %3s' % (m.getVal(x[i,j,k]), k, j, i))\n\noptimal value: 3420.0\nsend       85.0 of commodity   2 from factory   1 to customer   1\nsend      300.0 of commodity   3 from factory   1 to customer   1\nsend        6.0 of commodity   4 from factory   2 to customer   1\nsend       80.0 of commodity   1 from factory   3 to customer   1\nsend      400.0 of commodity   3 from factory   1 to customer   2\nsend      160.0 of commodity   2 from factory   2 to customer   2\nsend        7.0 of commodity   4 from factory   2 to customer   2\nsend      270.0 of commodity   1 from factory   3 to customer   2\nsend      350.0 of commodity   3 from factory   1 to customer   3\nsend      130.0 of commodity   2 from factory   2 to customer   3\nsend        4.0 of commodity   4 from factory   2 to customer   3\nsend      250.0 of commodity   1 from factory   3 to customer   3\nsend      200.0 of commodity   3 from factory   1 to customer   4\nsend        3.0 of commodity   4 from factory   2 to customer   4\nsend      160.0 of commodity   1 from factory   3 to customer   4\nsend       60.0 of commodity   2 from factory   3 to customer   4\nsend      150.0 of commodity   3 from factory   1 to customer   5\nsend        5.0 of commodity   4 from factory   2 to customer   5\nsend      180.0 of commodity   1 from factory   3 to customer   5\nsend       40.0 of commodity   2 from factory   3 to customer   5"
  },
  {
    "objectID": "nbs/20230308_scip/01_SCIP_install.html",
    "href": "nbs/20230308_scip/01_SCIP_install.html",
    "title": "SCIP - fast non-commercial solver got open source licence",
    "section": "",
    "text": "summary\nWe saw the basic components of pyscipopt in order to create an optimization model. In the following notebooks we will look at some classical problems and how to solve them using SCIP.\n\n\n\n\n\n\nReferences\n\nJoão Pedro Pedroso, Mikio Kubo, Abdur Rais, and Masakazu Muramatsu. 2019. Mathematical Optimization: Solving Problems Using SCIP and Python. Online. http://scipbook.readthedocs.io/.\n\nFootnotes\n\n\nhttps://www.scipopt.org/doc-8.0.3/html/↩︎"
  },
  {
    "objectID": "nbs/20230308_scip/02_SCIP_transport_problem.html",
    "href": "nbs/20230308_scip/02_SCIP_transport_problem.html",
    "title": "Transport problems with SCIP",
    "section": "",
    "text": "Suppose you can produce goods in different factories and sell them on different markets. Each factory has its own production capacity and each market has its own demand, which we may know after elaborating a survey. As the distances of the markets and the factories are different, we are looking for a transport route which minimizes the total costs.\nThe problem can be visualized as follows\n\n\n\nTransportProblem\n\n\nReference: (João Pedro Pedroso and Muramatsu 2019, introduction:Transport problem)\n\n\nAgain we assume that the reader is familiar with basic concepts of optimization, but we are writting the blog in a way that the unexperienced readers see the benefit of these techniques, while considering them as blakc boxes.\n\nSCIP multidic\nget slack variable values, sensitivity analysis, shadow prices, … (all synonyms)"
  },
  {
    "objectID": "nbs/20230308_scip/02_SCIP_transport_problem.html#sets",
    "href": "nbs/20230308_scip/02_SCIP_transport_problem.html#sets",
    "title": "Transport problems with SCIP",
    "section": "Sets",
    "text": "Sets\n\n\\(I\\) customer set\n\\(J\\) factory set"
  },
  {
    "objectID": "nbs/20230308_scip/02_SCIP_transport_problem.html#variables",
    "href": "nbs/20230308_scip/02_SCIP_transport_problem.html#variables",
    "title": "Transport problems with SCIP",
    "section": "Variables",
    "text": "Variables\n\n\\(x_{i,j}\\) amount of goods transported from factory \\(j\\) to customer \\(i\\)"
  },
  {
    "objectID": "nbs/20230308_scip/02_SCIP_transport_problem.html#parameter",
    "href": "nbs/20230308_scip/02_SCIP_transport_problem.html#parameter",
    "title": "Transport problems with SCIP",
    "section": "Parameter",
    "text": "Parameter\n\n\\(c_{i,j}\\) transportation costs from factory \\(i\\) to customer \\(j\\)\n\\(d_i\\) demand of customer \\(i\\)\n\\(m_j\\) production capacity of factory \\(j\\)"
  },
  {
    "objectID": "nbs/20230308_scip/02_SCIP_transport_problem.html#lp-model",
    "href": "nbs/20230308_scip/02_SCIP_transport_problem.html#lp-model",
    "title": "Transport problems with SCIP",
    "section": "LP-Model",
    "text": "LP-Model\n\\[\n\\begin{array}{llll}\n\\min & \\sum_{i,j} c_{i,j} x_{i,j} & & \\\\\ns.t. & \\sum_j x_{i,j}             & = d_i & \\forall i\\\\\n     & \\sum_i x_{i,j}             & \\leq m_j & \\forall j\\\\\n     & x_{i,j}                    & \\geq 0 & \\forall i,j\n\\end{array}\n\\]\n\nimport pyscipopt as scip\n\n\n# demand\nI, d = scip.multidict({1:80, 2:270, 3:250, 4:160, 5:180})\n# capacities\nJ, M = scip.multidict({1:500, 2:500, 3:500})\n\n\n# transport costs\nc = {(1,1):4,    (1,2):6,    (1,3):9,\n     (2,1):5,    (2,2):4,    (2,3):7,\n     (3,1):6,    (3,2):3,    (3,3):3,\n     (4,1):8,    (4,2):5,    (4,3):3,\n     (5,1):10,   (5,2):8,    (5,3):4,\n     }\n\n\nm = scip.Model()   \n\n# variables\nx = {}\nfor i in I:\n    for j in J:\n        x[i,j] = m.addVar(vtype = 'C', name = 'x(%s,%s)' % (i,j))\n    \n# constraints\nfor i in I:\n    m.addCons(scip.quicksum( x[i,j] for j in J if (i,j) in x) == d[i],\n              name = 'CustomerDemand(%s)' % i)\nfor j in J:\n    m.addCons(scip.quicksum( x[i,j] for i in I if (i,j) in x) <= M[j],\n              name = 'FactoryCapacity(%s)' % j)\n    \n# objective\nm.setObjective(scip.quicksum(c[i,j]*x[i,j] for (i,j) in x),\n               sense = 'minimize')   \n\nm.optimize()    \n\n\nprint(\"optimal value:\", m.getObjVal())\nepsilon = 1.e-6\nfor (i,j) in x:\n    if m.getVal(x[i,j]) > epsilon:\n        print('send %10s goods from factory %2s to customer %2s' % (m.getVal(x[i,j]), j, i))\n\noptimal value: 3350.0\nsend       80.0 goods from factory  1 to customer  1\nsend      270.0 goods from factory  2 to customer  2\nsend      230.0 goods from factory  2 to customer  3\nsend       20.0 goods from factory  3 to customer  3\nsend      160.0 goods from factory  3 to customer  4\nsend      180.0 goods from factory  3 to customer  5"
  },
  {
    "objectID": "nbs/20230308_scip/02_SCIP_transport_problem.html#example-continued",
    "href": "nbs/20230308_scip/02_SCIP_transport_problem.html#example-continued",
    "title": "Transport problems with SCIP",
    "section": "Example continued",
    "text": "Example continued\nSuppose you believe your factory capacity got tight and you are considering an expansion and you ask yourself the following questions:\n\nWhat kind of costs can be reduced by expanding each factory?\nWhat is the additional profit you can make if you get additional orders from each customer?\n\nIn order to investigate whether or not a factory should be expanded, we look at the values of the slack variables of the capacity constraints:\n\\[\n\\sum_i x_{i,j}\\leq M_j\n\\]\nWe recall that \\(x_{i,j}\\) denotes the amount of goods transported from factory \\(j\\) to market \\(i\\) and \\(M_j\\) denotes the capacity of factory \\(j\\)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  }
]