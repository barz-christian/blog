[
  {
    "objectID": "20220609_blending_models/01_blending.html",
    "href": "20220609_blending_models/01_blending.html",
    "title": "Blending models - Steel production",
    "section": "",
    "text": "In blending or product mix problems, one tries to mix or extract ingredients subject to quality constraints.\nWe start with the following easy example in which we have one product and different raw materials. This example is taken from [@gueret1999applications, chap. 6.1].\n\n\nWe want to produce a predefined quantity of a product, e.g. steel. The produced product must have certain characteristics (grades) - see section below. In stock we have different possible ingredients, e.g. ores, and these ingredients contribute differently to the requirements and have different availablility and prices - see section below.\nWe want to determine the recipie which minimizes the production costs.\n\n\nCode\nimport pandas as pd\nimport pyomo.environ as pyo"
  },
  {
    "objectID": "20220609_blending_models/01_blending.html#sets",
    "href": "20220609_blending_models/01_blending.html#sets",
    "title": "Blending models - Steel production",
    "section": "sets",
    "text": "sets\n\n\\(raw\\) - set of raw materials\n\\(comp\\) - set of grade requirements"
  },
  {
    "objectID": "20220609_blending_models/01_blending.html#variables",
    "href": "20220609_blending_models/01_blending.html#variables",
    "title": "Blending models - Steel production",
    "section": "variables",
    "text": "variables\n\n\\(use_r\\) - used quantity in optimal recipie of raw material \\(r\\)"
  },
  {
    "objectID": "20220609_blending_models/01_blending.html#parameter",
    "href": "20220609_blending_models/01_blending.html#parameter",
    "title": "Blending models - Steel production",
    "section": "parameter",
    "text": "parameter\n\n\\(demand\\) - demand of the product\n\\(produce\\) - produced quatity of the product\n\\(cost_r\\) - costs of raw material \\(r\\)\n\\(P_{rc}\\) - percentage of component \\(c\\) in raw material \\(r\\)\n\\(Pmin_c\\) - minimal requirement of component \\(c\\) in product\n\\(Pmax_c\\) - maximal requirement of component \\(c\\) in product"
  },
  {
    "objectID": "20220609_blending_models/01_blending.html#objective",
    "href": "20220609_blending_models/01_blending.html#objective",
    "title": "Blending models - Steel production",
    "section": "objective",
    "text": "objective\n\nfind the recipe with minimal costs fulfilling the requirements"
  },
  {
    "objectID": "20220609_blending_models/01_blending.html#constraints",
    "href": "20220609_blending_models/01_blending.html#constraints",
    "title": "Blending models - Steel production",
    "section": "constraints",
    "text": "constraints\n\n(c1) produced quatity is given by the sum of the used rat materials (in tons)\n(c2) lower limit on the components in the final product\n(c3) upper limit on the components in the final product\n(c4) use only available quatities of the raw materials\n(c5) produced quatity fulfills demands"
  },
  {
    "objectID": "20220609_blending_models/01_blending.html#deterministic-model",
    "href": "20220609_blending_models/01_blending.html#deterministic-model",
    "title": "Blending models - Steel production",
    "section": "deterministic model",
    "text": "deterministic model\n\\[\n\\begin{array}{llll}\n\\min & \\sum_{r\\in raw} cost_r \\cdot use_r & & \\\\\ns.t. & produce = \\sum_{r\\in raw} use_r & & (c1)\\\\\n     & \\sum_{r\\in raw} P_{rc}\\cdot use_r \\geq Pmin_c \\cdot produce & , \\forall c\\in comp & (c2)\\\\\n     & \\sum_{r\\in raw} P_{rc}\\cdot use_r \\leq Pmax_c \\cdot produce &  , \\forall c\\in comp & (c3)\\\\\n     & use_r \\leq avail_r &  , \\forall r\\in raw & (c4) \\\\\n     & produce \\geq demand & & (c5) \\\\\n     & use_r,produce \\geq 0 & & (c6)\n\\end{array}\n\\]\n\n\nCode\ndef alloy_blending(requirements,raw_mat, demand):\n    m = pyo.ConcreteModel('alloy production')\n    \n    # sets\n    m.raw = pyo.Set(initialize = raw_mat.raw_mat)\n    m.comp = pyo.Set(initialize = requirements.element)\n    \n    # parameter\n    @m.Param(m.raw, doc = 'costs of raw mat r')\n    def costs(m,r):\n        return raw_mat.loc[raw_mat['raw_mat'] == r, 'costs'].values[0]\n    @m.Param(m.raw, m.comp, doc = 'percentage of component c in raw material r')\n    def P(m,r,c):\n        return raw_mat.loc[raw_mat['raw_mat'] == r, c].values[0]\n    @m.Param(m.comp, doc= 'minimal percentage of component c in final product')\n    def Pmin(m,c):\n        return requirements.loc[requirements['element'] == c, 'min_grade'].values[0]\n    @m.Param(m.comp, doc= 'maximal percentage of component c in final product')\n    def Pmax(m,c):\n        return requirements.loc[requirements['element'] == c, 'max_grade'].values[0]\n    @m.Param(m.raw, doc = 'availability of raw materials')\n    def avail(m,r):\n        return raw_mat.loc[raw_mat['raw_mat'] == r, 'availability'].values[0]\n    @m.Param(doc = 'product demand')\n    def demand(m):\n        return demand\n    \n    # variables\n    m.use = pyo.Var(m.raw, domain = pyo.NonNegativeReals, doc = 'used tons of raw material r')\n    m.produced = pyo.Var(domain = pyo.NonNegativeReals, doc = 'tons produced')\n    \n    # objective\n    def objective(m):\n        return pyo.summation(m.costs, m.use)\n    m.OBJ = pyo.Objective(rule = objective(m), sense = pyo.minimize)\n    \n    # constraints\n    @m.Constraint(doc ='tons produced')\n    def c1(m):\n        return m.produced == pyo.summation(m.use)\n    \n    @m.Constraint(m.comp, doc = 'lower limit of grade in final product')\n    def c2(m, c):\n        return sum(m.P[r,c] * m.use[r] for r in m.raw) >= m.Pmin[c] * m.produced\n    @m.Constraint(m.comp, doc = 'upper limit of grade in final product')\n    def c3(m, c):\n        return sum(m.P[r,c] * m.use[r] for r in m.raw) <= m.Pmax[c] * m.produced\n    @m.Constraint(m.raw, doc = 'use component c maximal w.r.t. availability of c')\n    def c4(m, r):\n        return m.use[r] <= m.avail[r]\n    @m.Constraint(doc = 'produce at least the demand')\n    def c5(m):\n        return m.produced >= m.demand\n\n    \n    # solver\n    solver = pyo.SolverFactory('glpk')\n    solver.solve(m)\n    \n    return m"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html",
    "href": "20220621_jobshop/00_bottleneck_machine.html",
    "title": "Job shop scheduling",
    "section": "",
    "text": "Code\nimport pyomo.environ as pyo\nimport pyomo.gdp as gdp\nimport pandas as pd\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#optimal-vs.-empirical-schedules",
    "href": "20220621_jobshop/00_bottleneck_machine.html#optimal-vs.-empirical-schedules",
    "title": "Job shop scheduling",
    "section": "Optimal vs. empirical schedules",
    "text": "Optimal vs. empirical schedules\nIn order to see the benefit of mathematical optimization we proceed as follows:\n\nWe visualize and compute KPIs for certain empirical schedules.\nWe visualize and compute KPIs for optimal schedules with respect to different KPIs.\nWe determine an optimal solution for a given set of jobs and a given sets of machines."
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#example",
    "href": "20220621_jobshop/00_bottleneck_machine.html#example",
    "title": "Job shop scheduling",
    "section": "Example",
    "text": "Example\nIn our discussion we use the following example of jobs.\n\n\nCode\njobs = {\n    'A': {'release':2, 'duration': 5, 'due': 10},\n    'B': {'release':5, 'duration': 6, 'due': 21},\n    'C': {'release':4, 'duration': 8, 'due': 15},\n    'D': {'release':0, 'duration': 4, 'due': 10},\n    'E': {'release':0, 'duration': 2, 'due':  5},\n    'F': {'release':8, 'duration': 3, 'due': 15},\n    'G': {'release':9, 'duration': 2, 'due': 22}\n}\npd.DataFrame(jobs).T.rename(columns = {'release': 'release time', \n                                       'duration': 'duration in hours',\n                                      'due':'due time'})\n\n\n\n\n\n\n  \n    \n      \n      release time\n      duration in hours\n      due time\n    \n  \n  \n    \n      A\n      2\n      5\n      10\n    \n    \n      B\n      5\n      6\n      21\n    \n    \n      C\n      4\n      8\n      15\n    \n    \n      D\n      0\n      4\n      10\n    \n    \n      E\n      0\n      2\n      5\n    \n    \n      F\n      8\n      3\n      15\n    \n    \n      G\n      9\n      2\n      22"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#gantt-charts",
    "href": "20220621_jobshop/00_bottleneck_machine.html#gantt-charts",
    "title": "Job shop scheduling",
    "section": "GANTT charts",
    "text": "GANTT charts\nSchedules can be visualised using GANTT charts. In the next cells we define some helper functions, for example to plot a Gantt chart.\nAfterwards we consider empirical schedules, in particular we consider:\n\nFirst-In First-Out (FIFO)\nLast-In, First-Out (LIFO)\nShortest Processing Time First (SPT)\nEarliest Due Data (EDD)\n\n\n\nCode\n# copy and pasted from jeffrey !\ndef gantt(JOBS, SCHEDULE={}):\n    bw = 0.3\n    plt.figure(figsize=(12, 0.7*(len(JOBS.keys()))))\n    idx = 0\n    for j in sorted(JOBS.keys()):\n        x = JOBS[j]['release']\n        y = JOBS[j]['due']\n        plt.fill_between([x,y],[idx-bw,idx-bw],[idx+bw,idx+bw], color='cyan', alpha=0.6)\n        if j in SCHEDULE.keys():\n            x = SCHEDULE[j]['start']\n            y = SCHEDULE[j]['finish']\n            plt.fill_between([x,y],[idx-bw,idx-bw],[idx+bw,idx+bw], color='red', alpha=0.5)\n            plt.plot([x,y,y,x,x], [idx-bw,idx-bw,idx+bw,idx+bw,idx-bw],color='k')\n            plt.text((SCHEDULE[j]['start'] + SCHEDULE[j]['finish'])/2.0,idx,\n                'Job ' + j, color='white', weight='bold',\n                horizontalalignment='center', verticalalignment='center')\n        idx += 1\n\n    plt.ylim(-0.5, idx-0.5)\n    plt.title('Job Schedule')\n    plt.xlabel('Time')\n    plt.ylabel('Jobs')\n    plt.yticks(range(len(JOBS)), JOBS.keys())\n    plt.grid()\n    xlim = plt.xlim()\n    \n    if SCHEDULE:\n        for j in SCHEDULE.keys():\n            if 'machine' not in SCHEDULE[j].keys():\n                SCHEDULE[j]['machine'] = 1\n        MACHINES = sorted(set([SCHEDULE[j]['machine'] for j in SCHEDULE.keys()]))\n\n        plt.figure(figsize=(12, 0.7*len(MACHINES)))\n        for j in sorted(SCHEDULE.keys()):\n            idx = MACHINES.index(SCHEDULE[j]['machine'])\n            x = SCHEDULE[j]['start']\n            y = SCHEDULE[j]['finish']\n            plt.fill_between([x,y],[idx-bw,idx-bw],[idx+bw,idx+bw], color='red', alpha=0.5)\n            plt.plot([x,y,y,x,x], [idx-bw,idx-bw,idx+bw,idx+bw,idx-bw],color='k')\n            plt.text((SCHEDULE[j]['start'] + SCHEDULE[j]['finish'])/2.0,idx,\n                'Job ' + j, color='white', weight='bold',\n                horizontalalignment='center', verticalalignment='center')\n        plt.xlim(xlim)\n        plt.ylim(-0.5, len(MACHINES)-0.5)\n        plt.title('Machine Schedule')\n        plt.yticks(range(len(MACHINES)), MACHINES)\n        plt.ylabel('Machines')\n        plt.grid()\n\n\n\n\nCode\n# jeffrery's code !\ndef schedule(JOBS, order):\n    \"\"\"Schedule a dictionary of JOBS on a single machine in a specified order.\"\"\"\n    start = 0\n    finish = 0\n    SCHEDULE = {}\n    for job in order:\n        start = max(JOBS[job]['release'], finish)\n        finish = start + JOBS[job]['duration']\n        SCHEDULE[job] = {'start': start, 'finish': finish}\n    return SCHEDULE\n\n\n\n\nCode\n# mainly jeffrery's code !\ndef schedule_from_model(m, machines = 1):\n    SCHEDULE = {}\n    for j in m.jobs:\n        if machines == 1:\n            tmp = 1\n        else:\n            tmp = [mach for mach in machines if pyo.value(m.job_to_machine[j,mach]) == 1][0]\n        SCHEDULE[j] = {\n            'start': m.start[j](), \n            'finish': m.start[j]() + m.duration[j],\n            'machine': tmp\n        }\n    return SCHEDULE\n\n\n\n\nCode\n# jeffreys code\n## KPI for job schedule\ndef kpi(JOBS, SCHEDULE):\n    KPI = {}\n    KPI['Makespan'] = max(SCHEDULE[job]['finish'] for job in SCHEDULE)\n    KPI['Max Pastdue'] = max(max(0, SCHEDULE[job]['finish'] - JOBS[job]['due']) for job in SCHEDULE)\n    KPI['Sum of Pastdue'] = sum(max(0, SCHEDULE[job]['finish'] - JOBS[job]['due']) for job in SCHEDULE)\n    KPI['Number Pastdue'] = sum(SCHEDULE[job]['finish'] > JOBS[job]['due'] for job in SCHEDULE)\n    KPI['Number on Time'] = sum(SCHEDULE[job]['finish'] <= JOBS[job]['due'] for job in SCHEDULE)\n    KPI['Fraction on Time'] = KPI['Number on Time']/len(SCHEDULE)\n    return KPI"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#a-manual-schedule",
    "href": "20220621_jobshop/00_bottleneck_machine.html#a-manual-schedule",
    "title": "Job shop scheduling",
    "section": "A Manual Schedule",
    "text": "A Manual Schedule\nBy specifying schedules we can evaluate and compare them. The following snippet shows how the user can specify a schedule and judge its performance through the KPIs.\nWe invite the reader to spend some minutes trying to find a better schedule. Spoiler: The given schedule here is already optimal in a way we will see later.\n\n\nCode\n# define schedule\njob_order = ['E','A','D','F','B','G','C']\n\n# visualize schedule\nSCHEDULE = schedule(jobs, order=job_order)\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 30,\n 'Max Pastdue': 15,\n 'Sum of Pastdue': 16,\n 'Number Pastdue': 2,\n 'Number on Time': 5,\n 'Fraction on Time': 0.7142857142857143}"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#alphabetic-schedule",
    "href": "20220621_jobshop/00_bottleneck_machine.html#alphabetic-schedule",
    "title": "Job shop scheduling",
    "section": "Alphabetic schedule",
    "text": "Alphabetic schedule\nLets assume the schedule is given by the names of the Jobs. This chould represent a case in which the schedule is predefined through its names by a human or by previous processes.\n\n\nCode\nSCHEDULE = schedule(jobs, order=sorted(jobs.keys()))\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 32,\n 'Max Pastdue': 22,\n 'Sum of Pastdue': 68,\n 'Number Pastdue': 5,\n 'Number on Time': 2,\n 'Fraction on Time': 0.2857142857142857}"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#fifo---first-in-first-out",
    "href": "20220621_jobshop/00_bottleneck_machine.html#fifo---first-in-first-out",
    "title": "Job shop scheduling",
    "section": "FIFO - first in first out",
    "text": "FIFO - first in first out\nWe evaluate a schedule, in which the ordering is defined by the release time of the job, i.e. what comes first is done first.\n\n\nCode\ndef fifo(JOBS):\n    order_by_release = sorted(JOBS, key=lambda job: JOBS[job]['release'])\n    return schedule(JOBS, order_by_release)\n\ngantt(jobs, fifo(jobs))\nkpi(jobs, fifo(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 13,\n 'Sum of Pastdue': 31,\n 'Number Pastdue': 6,\n 'Number on Time': 1,\n 'Fraction on Time': 0.14285714285714285}"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#lifo---last-in-first-out",
    "href": "20220621_jobshop/00_bottleneck_machine.html#lifo---last-in-first-out",
    "title": "Job shop scheduling",
    "section": "LIFO - last in first out",
    "text": "LIFO - last in first out\nWe put the jobs on a stack as follows: At time \\(t\\) we put all jobs with release time equal to \\(t\\) on top of the stack. If the machine has a free capacity, we assign the job which is on top of the stack to the machine and remove the job from the stack.\n\n\nCode\ndef lifo(JOBS):\n    unfinished_jobs = set(JOBS.keys())\n    start = 0\n    while len(unfinished_jobs) > 0:\n        start = max(start, min(JOBS[job]['release'] for job in unfinished_jobs))\n        lifo = {job:JOBS[job]['release'] for job in unfinished_jobs if JOBS[job]['release'] <= start}\n        job = max(lifo, key=lifo.get)\n        finish = start + JOBS[job]['duration']\n        unfinished_jobs.remove(job)\n        SCHEDULE[job] = {'machine': 1, 'start': start, 'finish': finish}\n        start = finish\n    return SCHEDULE          \n    \ngantt(jobs, lifo(jobs))\nkpi(jobs, lifo(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 20,\n 'Sum of Pastdue': 34,\n 'Number Pastdue': 3,\n 'Number on Time': 4,\n 'Fraction on Time': 0.5714285714285714}"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#spt---shortest-processing-time",
    "href": "20220621_jobshop/00_bottleneck_machine.html#spt---shortest-processing-time",
    "title": "Job shop scheduling",
    "section": "SPT - shortest processing time",
    "text": "SPT - shortest processing time\nShortest processing time (SPT) is a scheduling policy that selects for execution the waiting job with the smallest execution time.\n\n\nCode\ndef spt(JOBS):\n    unfinished_jobs = set(JOBS.keys())\n    start = 0\n    while len(unfinished_jobs) > 0:\n        start = max(start, min(JOBS[job]['release'] for job in unfinished_jobs))\n        spt = {job:JOBS[job]['duration'] for job in unfinished_jobs if JOBS[job]['release'] <= start}\n        job = min(spt, key=spt.get)\n        finish = start + JOBS[job]['duration']\n        unfinished_jobs.remove(job)\n        SCHEDULE[job] = {'machine': 1, 'start': start, 'finish': finish}\n        start = finish\n    return SCHEDULE          \n    \ngantt(jobs, spt(jobs))\nkpi(jobs, spt(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 15,\n 'Sum of Pastdue': 18,\n 'Number Pastdue': 4,\n 'Number on Time': 3,\n 'Fraction on Time': 0.42857142857142855}"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#edd---earliest-due-date",
    "href": "20220621_jobshop/00_bottleneck_machine.html#edd---earliest-due-date",
    "title": "Job shop scheduling",
    "section": "EDD - earliest due date",
    "text": "EDD - earliest due date\nEarliest due date (EDD) is a dynamic priority scheduling algorithm used in real-time operating systems to place processes in a priority queue. Whenever a scheduling event occurs (task finishes, new task released, etc.) the queue will be searched for the process closest to its deadline.\n\n\nCode\ndef edd(JOBS):\n    unfinished_jobs = set(JOBS.keys())\n    start = 0\n    while len(unfinished_jobs) > 0:\n        start = max(start, min(JOBS[job]['release'] for job in unfinished_jobs))\n        edd = {job:JOBS[job]['due'] for job in unfinished_jobs if JOBS[job]['release'] <= start}\n        job = min(edd, key=edd.get)\n        finish = start + JOBS[job]['duration']\n        unfinished_jobs.remove(job)\n        SCHEDULE[job] = {'machine': 1, 'start': start, 'finish': finish}\n        start = finish\n    return SCHEDULE          \n    \ngantt(jobs, edd(jobs))\nkpi(jobs, edd(jobs))\n\n\n{'Makespan': 30,\n 'Max Pastdue': 8,\n 'Sum of Pastdue': 27,\n 'Number Pastdue': 5,\n 'Number on Time': 2,\n 'Fraction on Time': 0.2857142857142857}"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#modeling",
    "href": "20220621_jobshop/00_bottleneck_machine.html#modeling",
    "title": "Job shop scheduling",
    "section": "Modeling",
    "text": "Modeling\nWe give a algebraic representation of the model.\n\nSets\n\n\\(J\\) set of unique job IDs \\(j\\)\n\\(order:= \\{(i,j)~|~i,j\\in J\\}\\) - used to define weather job \\(j\\) is executed before job \\(i\\) or not\n\n\n\nParameter\n\n\\(due_j\\) due time of job \\(j\\)\n\\(duration_j\\) duration of job \\(j\\)\n\\(release_j\\) time job \\(j\\) becomes available for processing\n\n\n\nDecision variables\n\n\\(start_j\\) start of job \\(j\\)\n\n\n\nState variables\n\n\\(finished_j\\) time by which job \\(j\\) finishes\n\\(pastdue_j\\) time by which job \\(j\\) is past due\n\\(early_j\\) time by which job \\(j\\) is finished early\n\n\n\nConstraints\n\njob can not start until it is released for processing\n\n\\[\nstart_j\\geq release_j\n\\]\n\nexpressing timeline and how time variables are related\n\n\\[\n\\begin{array}{rl}\nstart_j + duration_j + early_j &= due_j + pastdue_j \\\\\nearly_j & \\geq 0 \\\\\npastdue_j & \\geq 0\n\\end{array}\n\\]\n\ndefinition of the objective makespan\n\n\\[\nfinish_j \\leq makespan\n\\]\n\ndefinition of state variable finish_j\n\n\\[\nstart_j + duration_j = finish_j\n\\]\n\nNo pair of jobs operates on the same machine at the same time.\n\nThis can be easily express as a set of disjunctions as follows:\n\\[\n\\left[finish_i \\leq start_j \\right] \\vee \\left[finish_j \\leq start_i \\right], \\; \\forall i<j\n\\]\n\n\nObjective\nAs we have mentioned in the introduction the application and circumstances define what an optimal schedule is."
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#implementation",
    "href": "20220621_jobshop/00_bottleneck_machine.html#implementation",
    "title": "Job shop scheduling",
    "section": "Implementation",
    "text": "Implementation\nThe following implementation allows optimizing with respect to the following objectives: - makespan, i.e. the time to complete all jobs - sum_pastdue, i.e. sum of past due\n\n\nCode\ndef model_1_machine(jobs, optimize = \"makespan\"):\n    \n    m = pyo.ConcreteModel()\n    \n    # sets\n    m.jobs = pyo.Set(initialize = jobs.keys())\n    m.order = pyo.Set(initialize = m.jobs * m.jobs, dimen = 2, filter = lambda m,i,j : i < j)\n    \n    # parameters\n    @m.Param(m.jobs, doc = \"job due time\")\n    def due(m,i):\n        return jobs[i]['due']\n    @m.Param(m.jobs, doc = \"job duration time\")\n    def duration(m,i):\n        return jobs[i]['duration']\n    @m.Param(m.jobs, doc = \"job release time\")\n    def release(m,i):\n        return jobs[i]['release']\n    \n    # upper bound on decision variables, in this case we choose the worst case \n    max_time = sum(m.duration[i] for i in m.jobs) + max(m.release[i] for i in m.jobs)\n    \n    # decision variables\n    m.start = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0, max_time))\n    ## additional variables\n    m.finish = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0, max_time))\n    m.pastdue = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0, max_time))\n    m.early = pyo.Var(m.jobs, domain = pyo.NonNegativeReals, bounds = (0,max_time))\n    \n    # addtional variables for objectives\n    m.makespan = pyo.Var(domain = pyo.NonNegativeReals, bounds = (0, max_time), doc = \"time until all jobs are done\")\n    m.maxpastdue = pyo.Var(domain = pyo.NonNegativeReals, bounds = (0,max_time), doc = \"time\")\n    m.ispastdue = pyo.Var(m.jobs, domain = pyo.Binary)\n    \n    # objective\n    if optimize == 'makespan':\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n    elif optimize == 'sum_pastdue':\n        m.OBJ = pyo.Objective(expr = sum([m.pastdue[i] for i in m.jobs]), sense = pyo.minimize)\n    else:\n        print('wrong value for parameter optimize. allowed are \"makespan\" or \"sum_pastdue\" optimize = makespan used instead.')\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n\n    # constraints\n    @m.Constraint(m.jobs)\n    def job_finish(m,i, doc = \"defines job time finish\"):\n        return m.finish[i] == m.start[i] + m.duration[i]\n    @m.Constraint(m.jobs, doc = \"release before start\")\n    def start_after_release(m,i):\n        return m.start[i] >= m.release[i]\n    @m.Constraint(m.jobs, doc =\"describe position of job w.r.t. time in schedule\")\n    def time_relations(m,i):\n        return m.start[i] + m.duration[i] + m.early[i] == m.due[i] + m.pastdue[i]\n    @m.Constraint(m.jobs, doc = \"finish time lower than make span\")\n    def finish_lower_makespan(m,i):\n        return m.finish[i] <= m.makespan\n    \n    m.schedule = gdp.Disjunction(m.order, rule = lambda m,i,j:\n                                [m.finish[i] <= m.start[j],\n                                 m.finish[j] <= m.start[i]])\n    \n    @m.Constraint(m.jobs, doc = \"past due lower than max past due\")\n    def pastdue_lower_maxpastdue(m,i):\n        return m.pastdue[i] <= m.maxpastdue\n    @m.Constraint(m.jobs, doc =\"\")\n    def pastdue_lower_max_time(m,i):\n        return m.pastdue[i] <= max_time * m.ispastdue[i]\n    pyo.TransformationFactory('gdp.hull').apply_to(m)\n    pyo.SolverFactory('glpk').solve(m)#.write()\n    \n    return m\n\n\n\nOptimal makespan\nBy defintion makespan is the time to complete all jobs.\n\n\nCode\nmodel = model_1_machine(jobs, optimize = \"makespan\")\nSCHEDULE = schedule_from_model(model)\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 30.0,\n 'Max Pastdue': 11.0,\n 'Sum of Pastdue': 29.0,\n 'Number Pastdue': 3,\n 'Number on Time': 4,\n 'Fraction on Time': 0.5714285714285714}"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#modeling-1",
    "href": "20220621_jobshop/00_bottleneck_machine.html#modeling-1",
    "title": "Job shop scheduling",
    "section": "Modeling",
    "text": "Modeling\nThe algebraic representation of the model is the following:"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#sets-1",
    "href": "20220621_jobshop/00_bottleneck_machine.html#sets-1",
    "title": "Job shop scheduling",
    "section": "Sets",
    "text": "Sets\n\n\\(machines\\) - elements are abbreviated with \\(m\\)\n\\(jobs\\) - elements are abbreviated with \\(j\\) or \\(i\\)\n\\(order:= jobs \\times jobs\\) - schedule order of jobs"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#parameters",
    "href": "20220621_jobshop/00_bottleneck_machine.html#parameters",
    "title": "Job shop scheduling",
    "section": "Parameters",
    "text": "Parameters\n\n\\(release_j\\)\n\\(duration_j\\)\n\\(due_j\\)\n\\(BigM\\) - big M integer in modeling the disjunctions"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#variables",
    "href": "20220621_jobshop/00_bottleneck_machine.html#variables",
    "title": "Job shop scheduling",
    "section": "Variables",
    "text": "Variables\n\nDecision variables\n\n\\(start_i\\) - time job \\(i\\) starts\n\\(job\\_to\\_machine_{j,m}\\) - binary variable, 1 iff job \\(j\\) is assigned to machine \\(m\\)\n\n\n\nState variables\n\n\\(pastdue_i\\) - time job \\(i\\) is past due\n\\(early_i\\) - time job \\(i\\) is finished early\n\n\n\nAssignment to machines\n\n\\(job\\_to\\_machine_{j,m}\\) - binary assingment of jobs to machine; \\(job\\_to\\_machine_{j,m}==1\\) iff job \\(j\\) is executed on \\(m\\)\n\n\n\nObjective vars\n\nmakespan - non negative real\nispastdue - binary, 1 iff job finish past due\nmaxpastdue - non negative real\n\n\n\nConstraints\nBecause the following model should work for different objective functions some constraints might be unused for a given objective function, but we believe it is easy to identify them.\n\\[\n\\begin{array}{llc}\n  start_j \\geq release_j & \\;\\forall j\\in jobs & c_1\\\\\n  start_j + duration_j + early_j = due_j + pastdue_j & \\;\\forall j\\in jobs &c_2\\\\\n  [early_j==0] \\vee [pastdue_j == 0] & \\;\\forall j\\in jobs & d_1\\\\\n  [pastdue_j == 0] \\vee [ispastdue_j == 1] & \\;\\forall j\\in jobs & d_2\\\\\n  \\sum_m jobs\\_to\\_machine_{j,m} = 1 & \\;\\forall j\\in jobs, \\forall m \\in machines & c_3\\\\\n  pastdue_j <= maxpastdue & \\;\\forall j\\in jobs & c_4\\\\\n  start_j + duration_j <= makespan & \\;\\forall j\\in jobs & c_5\\\\\n  [T1] \\vee_{i,j,m} [T2] & \\;\\forall i,j \\in order, \\forall m \\in machines & d_3\n\\end{array}\n\\]\nwhere \\[\n\\begin{array}{c}\nT1 := start_i + duration_i \\leq start_j + M(1-jobs\\_to\\_machine_{i,m}) +  M(1-jobs\\_to\\_machine_{j,m})\\\\\nT2 := start_j + duration_j \\leq start_i + M(1-jobs\\_to\\_machine_{i,m}) +  M(1-jobs\\_to\\_machine_{j,m})\n\\end{array}\n\\]\n\n\nConstraints explaination\n\n\\(c_1\\) job starts after its release\n\\(c_2\\) relation among time variables - required because not all jobs may finish before their due time\n\\(d_1\\) job is either early or pastdue\n\\(d_2\\) definition of objective variable ispastdue\n\\(c_3\\) each job is assign to one and only one machine\n\\(c_4\\) definition of objective variable maxpastdue\n\\(c_5\\) definition of objective variable makespan\n\\(d_3\\) job \\(j\\) does not start before previous job \\(i\\) has finished on machine \\(m\\)"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#example-scheduling-multiple-machines",
    "href": "20220621_jobshop/00_bottleneck_machine.html#example-scheduling-multiple-machines",
    "title": "Job shop scheduling",
    "section": "Example scheduling multiple machines",
    "text": "Example scheduling multiple machines\nWe consider two machines which should perform the following jobs:\n\n\nCode\nmachines = ['1','2']\njobs = {\n    'A': {'release':2, 'duration': 5, 'due': 10},\n    'B': {'release':5, 'duration': 6, 'due': 21},\n    'C': {'release':4, 'duration': 8, 'due': 15},\n    'D': {'release':0, 'duration': 4, 'due': 10},\n    'E': {'release':0, 'duration': 2, 'due':  5},\n    'F': {'release':8, 'duration': 3, 'due': 15},\n    'G': {'release':9, 'duration': 2, 'due': 22}\n}\n\n\n\n\nCode\ndef model_multiple_machines(jobs, machines, optimize = 'makespan'):\n    #instanciate model\n    m = pyo.ConcreteModel(\"multiple jobs, multiple workers\")\n    \n    # index sets\n    m.jobs = pyo.Set(initialize = jobs.keys())\n    m.machines = pyo.Set(initialize = machines)\n    m.order = pyo.Set(initialize = m.jobs * m.jobs, dimen = 2, filter = lambda m,i,j: i<j)\n    \n    # parameters\n    @m.Param(m.jobs, doc = \"job due time\")\n    def due(m,i):\n        return jobs[i]['due']\n    @m.Param(m.jobs, doc = \"job duration time\")\n    def duration(m,i):\n        return jobs[i]['duration']\n    @m.Param(m.jobs, doc = \"job release time\")\n    def release(m,i):\n        return jobs[i]['release']\n    # doc = \"big M integer in modeling disjunctions\" and apply hull transform\n    BigM = max([m.release[j] for j in m.jobs]) + sum([m.duration[j] for j in m.jobs])\n    \n    # variables\n    ## decision / timeline variables\n    m.start = pyo.Var(m.jobs, domain = pyo.NonNegativeReals,\n                      bounds = (0, 1000) ,\n                      doc = \"start time of job\")\n    m.pastdue = pyo.Var(m.jobs, domain = pyo.NonNegativeReals,\n                        bounds = (0, 1000),\n                        doc = \"time job is past due\")\n    m.early = pyo.Var(m.jobs, domain = pyo.NonNegativeReals,\n                      bounds = (0, 10000),\n                      doc = \"time job is finished early\")\n    \n    ## objective variables\n    m.makespan = pyo.Var(domain = pyo.NonNegativeReals, doc = \"time to complete all jobs\")\n    m.ispastdue = pyo.Var(m.jobs, domain = pyo.Binary, doc = \"binary iff job is overdue\")\n    m.maxpastdue = pyo.Var(domain = pyo.NonNegativeReals, doc = \"\")\n    \n    ## additional variales\n    m.job_to_machine = pyo.Var(m.jobs, m.machines, domain = pyo.Binary, doc = \"binary assignment job to machine\")\n    \n    # objective\n    if optimize == 'makespan':\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n    elif optimize == 'sum_pastdue':\n        m.OBJ = pyo.Objective(expr = sum([m.pastdue[i] for i in m.jobs]), sense = pyo.minimize)\n    else:\n        print('wrong value for parameter optimize. allowed are \"makespan\" or \"sum_pastdue\" optimize = makespan used instead.')\n        m.OBJ = pyo.Objective(expr = m.makespan, sense = pyo.minimize)\n\n    # constraint / disjunctions\n    @m.Constraint(m.jobs, doc = \"job start after release\")\n    def c1(m,i):\n        return m.start[i] >= m.release[i]\n    \n    @m.Constraint(m.jobs, doc = \"time variable relation\")\n    def c2(m,i):\n        return m.start[i] + m.duration[i] + m.early[i] == m.due[i] + m.pastdue[i]\n    \n    @m.Disjunction(m.jobs, doc = \"job either early or pastdue\")\n    def d1(m,i):\n        return [m.early[i]==0, m.pastdue[i]==0]\n    \n    @m.Disjunction(m.jobs, doc = \"\")\n    def d2(m,j):\n        return [m.pastdue[j] == 0, m.ispastdue[j] == 1],\n    \n    @m.Constraint(m.jobs, doc = \"each job is assigned to one and only one machine\")\n    def c3(m,j):\n        return (sum(m.job_to_machine[j,machine] for machine in m.machines) == 1)\n    \n    @m.Constraint(m.jobs, doc = \"define objective variable maxpastdue\")\n    def  c4(m,j):\n        return m.pastdue[j] <= m.maxpastdue\n    \n    @m.Constraint(m.jobs, doc = \"define objective variable makespan\")\n    def c6(m,i):\n        return m.start[i] + m.duration[i] <= m.makespan\n    \n    @m.Disjunction(m.machines, m.order, doc = \"ordering of jobs\")\n    def d3(m, machine, i,j):\n        return [m.start[i] + m.duration[i] <= m.start[j] + BigM * ((1 - m.job_to_machine[i,machine]) + (1 - m.job_to_machine[j,machine])),\n                m.start[j] + m.duration[j] <= m.start[i] + BigM * ((1 - m.job_to_machine[i,machine]) + (1 - m.job_to_machine[j,machine]))\n               ]\n    transform = pyo.TransformationFactory('gdp.hull')\n    transform.apply_to(m)\n    # solve model\n    pyo.SolverFactory('glpk').solve(m)\n    return m"
  },
  {
    "objectID": "20220621_jobshop/00_bottleneck_machine.html#optimal-makespan---multiple-machines",
    "href": "20220621_jobshop/00_bottleneck_machine.html#optimal-makespan---multiple-machines",
    "title": "Job shop scheduling",
    "section": "Optimal makespan - multiple machines",
    "text": "Optimal makespan - multiple machines\n\n\nCode\nmodel = model_multiple_machines(jobs, machines, optimize = 'makespan')\nSCHEDULE = schedule_from_model(model, machines)\ngantt(jobs, SCHEDULE)\nkpi(jobs, SCHEDULE)\n\n\n{'Makespan': 15.0,\n 'Max Pastdue': 0,\n 'Sum of Pastdue': 0,\n 'Number Pastdue': 0,\n 'Number on Time': 7,\n 'Fraction on Time': 1.0}"
  },
  {
    "objectID": "20230717_ORTools/02_8queens.html",
    "href": "20230717_ORTools/02_8queens.html",
    "title": "blog",
    "section": "",
    "text": "import sys\nimport time\nfrom ortools.sat.python import cp_model\n\n\nmodel = cp_model.CpModel()\n\n\n# create variables\nboard_size = 4\nqueens = [\n    model.NewIntVar(0, board_size - 1, 'x%i' % i) for i in range(board_size)\n]\n\n\n# create constraints\n# All rows must be different.\nmodel.AddAllDifferent(queens)\n\n# No two queens can be on the same diagonal.\nmodel.AddAllDifferent(queens[i] + i for i in range(board_size))\nmodel.AddAllDifferent(queens[i] - i for i in range(board_size))\n\n<ortools.sat.python.cp_model.Constraint>\n\n\n\nclass NQueenSolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print intermediate solutions.\"\"\"\n\n    def __init__(self, queens):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__queens = queens\n        self.__solution_count = 0\n        self.__start_time = time.time()\n\n    def solution_count(self):\n        return self.__solution_count\n\n    def on_solution_callback(self):\n        current_time = time.time()\n        print('Solution %i, time = %f s' %\n              (self.__solution_count, current_time - self.__start_time))\n        self.__solution_count += 1\n\n        all_queens = range(len(self.__queens))\n        for i in all_queens:\n            for j in all_queens:\n                if self.Value(self.__queens[j]) == i:\n                    # There is a queen in column j, row i.\n                    print('Q', end=' ')\n                else:\n                    print('_', end=' ')\n            print()\n        print()\n\n\nsolver = cp_model.CpSolver()\nsolution_printer = NQueenSolutionPrinter(queens)\nsolver.parameters.enumerate_all_solutions = True\nsolver.Solve(model, solution_printer)\n\nSolution 0, time = 0.008995 s\n_ Q _ _ \n_ _ _ Q \nQ _ _ _ \n_ _ Q _ \n\nSolution 1, time = 0.010817 s\n_ _ Q _ \nQ _ _ _ \n_ _ _ Q \n_ Q _ _ \n\n\n\n4"
  },
  {
    "objectID": "20230710_garden/02_strippacking.html",
    "href": "20230710_garden/02_strippacking.html",
    "title": "Strip packing problem",
    "section": "",
    "text": "In this blog post we give a brief intorduction to the strip packing problem and its application. We will see for different variants of the problem the algebraic represenations as a MILP and pyomo implementions using the GDP extension for generalized disjunctive programming.\nIn case that your are not familiar with disjunctive programming, let me briefly describe it as a framework to include logic or conditional contraints in an algebraic model. Typical applications of disjunctive programming are: ordering of tasks (e.g. in a production process), choosing optimal route in a circuit of organizing complex projects in a time saving manner. Typical techniques are refomulation as mixed interger program, Big-M reformulation and Hull reformulation.\n\n\nThe strip packing problem is a cutting and packing problem. In its basic form we want to pack rectangles on a two dimensional strip of fixed width and virtually infinite height. In other variants consider the different geometry of the packed objects, the dimension (e.g. backing of boxes in 3 dimensions) or the structure of the packing, e.g. guillotine packing. The strip packing problem contains as a special case the bin packing problem and hence its NP-hard.\nThere exists various approximation methods, such as heuristics and metaheuristcs, to solve the two dimensional strip packing problem.\n\n\n\nThe list of applications mainly steam from which inspired this blog https://mobook.github.io/MO-book/notebooks/03/strip-packing.html:\n\ncutting out of a sheet of material with fixed width but “infinite length”, e.g. paper or textitle cuts\nplacement of marco cells in semiconductor layouts\nworkstation layout in a manufacturing facility\nscheduling allocations of a common resource.\n\nMy personal motivation was an optimized bed planning in the garden. But because its model containts additional modifications I wanted to blog first about one of its core problem.\n\n\nCode\nimport pyomo.environ as pyo\nimport pyomo.gdp as gdp\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle \n\n\n\n\n\nWe randomly generate data. Here each row represents a box of width \\(w\\) and height \\(h\\).\n\n\nCode\n# helper functions\n\n## nb param\nnumber_of_boxes = 5\nshelf_depth = 1 # will be overwritten\nnp.random.seed(1111)\n\n# data generation\n\ndef gen_box(number_of_boxes = number_of_boxes, wlow=1, whigh=100, hlow=1, hhigh=100):\n    \"\"\"generates random number_of_boxes data, where width of each box varies between wlow and whigh, and heigth within hlow and hheigth \"\"\"\n    return pd.DataFrame({\n    'w': np.random.randint(wlow, whigh, size = number_of_boxes),\n    'h': np.random.randint(hlow, hhigh, size = number_of_boxes),\n    })\n\n\n## data generation\nboxes = gen_box()\ndata ={\n    'data' : boxes,\n    'solver' : 'cbc',\n    'model_name': 'strip_packing',\n    'shelf_depth' : 2 * boxes['h'].max()\n}\n\nshelf_depth = 2 * data['data']['h'].max()\n\n\n\n\nCode\n# inspect data\ndisplay(data['data'])\n\n\n\n\n\n\n  \n    \n      \n      w\n      h\n    \n  \n  \n    \n      0\n      29\n      53\n    \n    \n      1\n      56\n      25\n    \n    \n      2\n      82\n      23\n    \n    \n      3\n      13\n      21\n    \n    \n      4\n      35\n      12\n    \n  \n\n\n\n\n\n\nCode\ndef _packing(df):\n    \"\"\"temp function to transform input data into a df like the solution for visualization\"\"\"\n    dt = df.copy()\n    dt['x1'] = dt['w'].cumsum() - dt['w']\n    dt['x2'] = dt['w'].cumsum()\n    dt['y1'] = 0\n    dt['y2'] = dt['h']\n    dt['r'] = 0\n    return dt\n\ndef plot_solution(sol, shelf_depth = shelf_depth):\n    \"\"\"plot items bounding boxes\"\"\"\n    \n    fig, ax = plt.subplots()\n    \n    for i, x, y, w, h, r in zip(sol.index, sol['x1'], sol['y1'], sol['w'], sol['h'], sol['r']):\n        color = 'g'\n        # if box rotated then exchange heigth and width and use red as color\n        if r:\n            h, w = w, h\n            color = 'r'\n        ax.add_patch(Rectangle((x, y), w, h, \n                               edgecolor='k', facecolor=color, alpha=0.6))\n        # place item name in the middle of each box\n        ax.annotate(i, (x+w/2, y+h/2), color='w', weight='bold', fontsize=12, ha='center', va='center')\n    \n    # set axis limits\n    ax.set_xlim(0, 1.1*sol[\"w\"].sum())\n    ax.set_ylim(0, shelf_depth*1.1)\n    \n    # draw line for total used width\n    ax.axvline(sol[\"x2\"].max(), ymin = 0, ymax = shelf_depth/ax.get_ylim()[1],\n               label=\"shelf width $W$\", color=\"r\")\n    ax.fill_between([0, ax.get_xlim()[1]], [shelf_depth, shelf_depth], color=\"c\", alpha=0.2)\n    ax.set_title('packing')\n    ax.set_xlabel(\"width\")\n    ax.set_ylabel(\"heigth\")"
  },
  {
    "objectID": "20230710_garden/02_strippacking.html#algebraic-model",
    "href": "20230710_garden/02_strippacking.html#algebraic-model",
    "title": "Strip packing problem",
    "section": "algebraic model",
    "text": "algebraic model\n\nsets\n\n\\(I=\\{1,\\ldots,n\\}\\) set of boxes to be packed\n\\(order:=\\{(i,j) | i,j\\in I,\\; i<j\\}\\) used to define the packing order\n\n\n\nparam\n\n\\(w_i\\) width of box i\n\\(h_i\\) heigth of box i\n\n\n\nvars\n\n\\(W\\) total used width\n\\(x1_i\\) left x-coordinate of box i\n\\(x2_i\\) right x-coordinate of box i\n\\(y1_i\\) left y-coordinate of box i\n\\(y2_i\\) right 1-coordinate of box i\n\n\n\nconstraints\n\nbox width: left x coordinate and right x coordinate of box i differ by width of box i, i.e. \\(x_{2,i}=x_{1,i}+w_i\\)\nno box is placed after total used width, i.e. \\(x_{2,i} \\leq W\\)\nno overlap: either box i is placed before j or j before i, i.e. \\(x_{1,i} \\leq x_{1,j}\\) or \\(x_{1,j} \\leq x_{1,i}\\)\n\n\n\nobjective\n\nminimize total used width \\(W\\)\n\n\n\nmodel\n\\[\n\\begin{array}{lll}\n\\min & W & \\\\\ns.t. & x_{i,2} \\leq W & \\forall i\\\\\n     & x_{i,1},x_{i,2} \\geq 0 & \\forall i\\\\\n     & y_{i,1} = 0 & \\forall i\\\\\n     & [x_{i,2}\\leq x_{j,1}] \\vee [x_{j,2} \\leq x_{i,1}] & \\forall i < j\n\\end{array}     \n\\]\n\n\nRemark\nFor the variants of the strip packing problem considered here its easy to give bounds on the descision variables as an upper bound on the shelf width. For simplicity we use: \\[\nW_B:=\\sum w_i\n\\]"
  },
  {
    "objectID": "20230710_garden/02_strippacking.html#pyomo-implementation",
    "href": "20230710_garden/02_strippacking.html#pyomo-implementation",
    "title": "Strip packing problem",
    "section": "Pyomo implementation",
    "text": "Pyomo implementation\n\n\nCode\n# pyomo implementation\n\ndef SP_simple(data):\n    \"\"\"simple strip packing, but useful to study good/new neighboor constraints later\"\"\"\n    \n    # simple upper bound\n    w_bound = data['data']['w'].sum()\n    \n    # instanciate model\n    m = pyo.ConcreteModel(data['model_name'])\n    # sets\n    m.I = pyo.Set(initialize = data['data'].index, doc = 'items')\n    m.Order = pyo.Set(initialize = m.I * m.I, filter = lambda m,i,j: i<j)\n    \n    # vars\n    m.x1 = pyo.Var(m.I, domain = pyo.NonNegativeReals, bounds = (0,w_bound))\n    m.x2 = pyo.Var(m.I, domain = pyo.NonNegativeReals, bounds = (0,w_bound))\n    m.W = pyo.Var(domain = pyo.NonNegativeReals, doc = 'total width, to be optimized')\n    m.r = pyo.Var(domain = pyo.Boolean, initialize = False, doc = 'not used in no rotation model')\n    \n    # objective\n    m.OBJ = pyo.Objective(expr = m.W, sense = pyo.minimize)\n    \n    # param\n    @m.Param(m.I)\n    def w(m,i):\n        return data['data'].filter(items = [i], axis = 0)['w'].values[0]\n    \n    # constraints\n    @m.Constraint(m.I, doc = 'determines box i size')\n    def bounding_box(m,i):\n        return m.x2[i] == m.x1[i] + m.w[i]\n    \n    @m.Constraint(m.I, doc = 'defines total width, to be optimized')\n    def total_width(m,i):\n        return m.x2[i] <= m.W\n    \n    @m.Disjunction(m.Order, xor=True)\n    def no_overlap(m, i, j):\n        return [m.x2[i] <= m.x1[j],\n                m.x2[j] <= m.x1[i]]\n       \n    \n    pyo.TransformationFactory(\"gdp.bigm\").apply_to(m)\n    \n    # choose solver and apply solver\n    solver = pyo.SolverFactory(data['solver'])\n    solver.solve(m)\n    \n    # extract solution\n    sol = data['data'].copy()\n    # extract coords from solution\n    sol['x1'] = [pyo.value(m.x1[i]) for i in m.I]\n    sol['x2'] = [pyo.value(m.x2[i]) for i in m.I]\n    # placeholder\n    sol['y1'] = [0 for i in m.I]\n    sol['y2'] = sol['h']\n    sol['r'] = [False for i in m.I]\n        \n    return sol\n\n\n\n\nCode\n%%time\nsol = SP_simple(data)\n# visualise sollution\nplot_solution(sol)\n\n\nCPU times: user 104 ms, sys: 10.9 ms, total: 114 ms\nWall time: 481 ms"
  },
  {
    "objectID": "20230710_garden/02_strippacking.html#algebraic-model-with-roation",
    "href": "20230710_garden/02_strippacking.html#algebraic-model-with-roation",
    "title": "Strip packing problem",
    "section": "algebraic model with roation",
    "text": "algebraic model with roation\n\\[\n\\begin{array}{lll}\n\\min & W & \\\\\ns.t. & x_{i,2} \\leq W & \\forall i\\\\\n     & x_{i,1},x_{i,2} \\geq 0 & \\forall i\\\\\n     & y_{i,1} = 0 & \\forall i\\\\\n     & [x_{i,2}\\leq x_{j,1}] \\vee [x_{j,2} \\leq x_{i,1}] & \\forall i < j\\\\\n     & \\left[ \\begin{array}{ll}\n     r_i= & false\\\\\n     x_{i,2} = & x_{i,1} + w_i\\\\\n     y_{i,2} = & y_{i,1} + h_i\n     \\end{array} \\right] \\vee\n     \\left[ \\begin{array}{ll}\n     r_i= & true\\\\\n     x_{i,2} = & x_{i,1} + h_i\\\\\n     y_{i,2} = & y_{i,1} + w_i\n     \\end{array}\\right] & \\forall i < j\n\\end{array}     \n\\]"
  },
  {
    "objectID": "20230710_garden/02_strippacking.html#pyomo-implementation-1",
    "href": "20230710_garden/02_strippacking.html#pyomo-implementation-1",
    "title": "Strip packing problem",
    "section": "Pyomo implementation",
    "text": "Pyomo implementation\n\n\nCode\ndef SP_rot(data):\n    \"\"\"strip packing with rotation\"\"\"\n    \n    W_ub = data['data']['w'].sum()\n    \n    m = pyo.ConcreteModel()\n    \n    # sets\n    m.I = pyo.Set(initialize = data['data'].index, doc = 'plants')\n    m.Order = pyo.Set(initialize = m.I * m.I, filter = lambda m,i,j:i<j, doc ='ordering of plants')\n    \n    # vars\n    m.W = pyo.Var(bounds = (0,W_ub), doc = 'total optimal width')\n    m.x1 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'LHS of item i on x axis')\n    m.x2 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'RHS of item i on x axis')\n    m.y1 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'LHS of item i on y axis')\n    m.y2 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'RHS of item i on y axis')\n    m.r = pyo.Var(m.I, domain = pyo.Boolean)\n    \n    # objective\n    @m.Objective()\n    def minimal_width(m):\n        return m.W\n    \n    # param\n    @m.Param(m.I)\n    def w(m,i):\n        return data['data'].filter(items = [i], axis = 0)['w'].values[0]\n    @m.Param(m.I)\n    def h(m,i):\n        return data['data'].filter(items = [i], axis = 0)['h'].values[0]\n    \n    # constraints\n    @m.Constraint(m.I)\n    def c1(m,i):\n        return m.x2[i] <= m.W\n    @m.Constraint(m.I)\n    def y1_loc(m,i):\n        return m.y1[i] == 0\n    @m.Disjunction(m.I)\n    def rotation(m,i):\n        return [\n            [m.r[i] == False, \n             m.x2[i] == m.x1[i] + m.w[i],\n             m.y2[i] == m.y1[i] + m.h[i]\n            ],\n            [m.r[i] == True,\n             m.x2[i] == m.x1[i] + m.h[i],\n             m.y2[i] == m.y1[i] + m.w[i]\n            ]\n        ]\n    @m.Disjunction(m.Order)\n    def no_overlap(m,i,j):\n        return [\n            [m.x2[i] <= m.x1[j]],\n            [m.x2[j] <= m.x1[i]]\n        ]\n    \n    pyo.TransformationFactory(\"gdp.bigm\").apply_to(m)\n    \n    # choose solver and apply solver\n    solver = pyo.SolverFactory(data['solver'])\n    solver.solve(m)\n    \n    # extract solution\n    sol = data['data'].copy()\n    # extract coords from solution\n    sol['x1'] = [pyo.value(m.x1[i]) for i in m.I]\n    sol['x2'] = [pyo.value(m.x2[i]) for i in m.I]\n    # placeholder\n    sol['y1'] = [pyo.value(m.y1[i]) for i in m.I]\n    sol['y2'] = [pyo.value(m.y2[i]) for i in m.I]\n    sol['r'] = [pyo.value(m.r[i]) for i in m.I]\n    \n    return sol\n\n\nIn order to see when a rotation was applied we plot rotated boxes in red.\n\n\nCode\n%%time\nsol_rot = SP_rot(data)\nplot_solution(sol_rot)\n\n\nCPU times: user 99.2 ms, sys: 21 ms, total: 120 ms\nWall time: 561 ms"
  },
  {
    "objectID": "20230710_garden/02_strippacking.html#algebraic-model-1",
    "href": "20230710_garden/02_strippacking.html#algebraic-model-1",
    "title": "Strip packing problem",
    "section": "algebraic model",
    "text": "algebraic model\n\nAdditional constraints\n\nupper \\(y\\) coordinate of box does not exceed shelf depth \\(D\\)\nno overlap of boxes in y-axis\n\n\n\nModel\n\\[\n\\begin{array}{lll}\n\\min & W & \\\\\ns.t. & x_{i,2} \\leq W & \\forall i\\\\\n     & y_{i,2} \\leq D & \\forall i\\\\\n     & x_{i,1},x_{i,2}, y_{i,1}, y_{i,2} \\geq 0 & \\forall i\\\\\n     & y_{i,1} = 0 & \\forall i\\\\\n     & [x_{i,2}\\leq x_{j,1}] \\vee\n       [x_{j,2} \\leq x_{i,1}] \\vee       \n       [y_{i,2}\\leq y_{j,1}] \\vee\n       [y_{j,2} \\leq y_{i,1}]\n       & \\forall i < j\\\\\n     & \\left[ \\begin{array}{ll}\n     r_i= & false\\\\\n     x_{i,2} = & x_{i,1} + w_i\\\\\n     y_{i,2} = & y_{i,1} + h_i\n     \\end{array} \\right] \\vee\n     \\left[ \\begin{array}{ll}\n     r_i= & true\\\\\n     x_{i,2} = & x_{i,1} + h_i\\\\\n     y_{i,2} = & y_{i,1} + w_i\n     \\end{array}\\right] & \\forall i < j\n\\end{array}     \n\\]"
  },
  {
    "objectID": "20230710_garden/02_strippacking.html#pyomo-implementation-2",
    "href": "20230710_garden/02_strippacking.html#pyomo-implementation-2",
    "title": "Strip packing problem",
    "section": "Pyomo implementation",
    "text": "Pyomo implementation\n\n\nCode\ndef SP_2dim_rot(data):\n    \"\"\"strip packing with rotation in 2 dimension\"\"\"\n    \n    W_ub = data['data']['w'].sum()\n    \n    m = pyo.ConcreteModel()\n    \n    # sets\n    m.I = pyo.Set(initialize = data['data'].index, doc = 'plants')\n    m.Order = pyo.Set(initialize = m.I * m.I, filter = lambda m,i,j:i<j, doc ='ordering of plants')\n    \n    # vars\n    m.W = pyo.Var(bounds = (0,W_ub), doc = 'total optimal width')\n    m.x1 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'LHS of item i on x axis')\n    m.x2 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'RHS of item i on x axis')\n    m.y1 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'LHS of item i on y axis')\n    m.y2 = pyo.Var(m.I, bounds = (0,W_ub), doc = 'RHS of item i on y axis')\n    m.r = pyo.Var(m.I, domain = pyo.Boolean)\n    \n    # objective\n    @m.Objective()\n    def minimal_width(m):\n        return m.W\n    \n    # param\n    @m.Param(m.I)\n    def w(m,i):\n        return data['data'].filter(items = [i], axis = 0)['w'].values[0]\n    @m.Param(m.I)\n    def h(m,i):\n        return data['data'].filter(items = [i], axis = 0)['h'].values[0]\n    m.shelf_depth = pyo.Param(mutable = True,\n                              initialize = data['shelf_depth'])\n    \n    # constraints\n    @m.Constraint(m.I)\n    def minimize_width(m,i):\n        return m.x2[i] <= m.W\n    @m.Constraint(m.I)\n    def max_heigth(m,i):\n        return m.y2[i] <= m.shelf_depth\n    \n    @m.Disjunction(m.I)\n    def rotation(m,i):\n        return [\n            [m.r[i] == False, \n             m.x2[i] == m.x1[i] + m.w[i],\n             m.y2[i] == m.y1[i] + m.h[i]\n            ],\n            [m.r[i] == True,\n             m.x2[i] == m.x1[i] + m.h[i],\n             m.y2[i] == m.y1[i] + m.w[i]\n            ]\n        ]\n    @m.Disjunction(m.Order)\n    def no_overlap(m,i,j):\n        return [\n            [m.x2[i] <= m.x1[j]],\n            [m.x2[j] <= m.x1[i]],\n            [m.y2[i] <= m.y1[j]],\n            [m.y2[j] <= m.y1[i]]\n        ]\n    \n    pyo.TransformationFactory(\"gdp.bigm\").apply_to(m)\n    \n    # choose solver and apply solver\n    solver = pyo.SolverFactory(data['solver'])\n    solver.solve(m)\n    \n    # extract solution\n    sol = data['data'].copy()\n    # extract coords from solution\n    sol['x1'] = [pyo.value(m.x1[i]) for i in m.I]\n    sol['x2'] = [pyo.value(m.x2[i]) for i in m.I]\n    # placeholder\n    sol['y1'] = [pyo.value(m.y1[i]) for i in m.I]\n    sol['y2'] = [pyo.value(m.y2[i]) for i in m.I]\n    sol['r'] = [pyo.value(m.r[i]) for i in m.I]\n    \n    return sol\n\n\n\n\nCode\n%%time\nsol_rot = SP_2dim_rot(data)\nplot_solution(sol_rot)\n\n\nCPU times: user 118 ms, sys: 47.6 ms, total: 166 ms\nWall time: 271 ms"
  },
  {
    "objectID": "20230710_garden/01_knappsack.html",
    "href": "20230710_garden/01_knappsack.html",
    "title": "knappsack problem",
    "section": "",
    "text": "notebook will be part of a series\nlong term goal will be a bilevel programm to optimize bed planning in the private garden\ncurrent idea:\n\nupper level problem: “knappsack problem”\nlower level problem: “strip packing problem”"
  },
  {
    "objectID": "20230710_garden/01_knappsack.html#outline",
    "href": "20230710_garden/01_knappsack.html#outline",
    "title": "knappsack problem",
    "section": "outline",
    "text": "outline\n\nintroduce knappsack problem\nmath description\npyomo implementation\nexample\n\nThe knappsack problem appears in a wide variety of real world decision making processses, for example optimal resource allocation in networks, optimal loading of containes in shipping, portfolio selection in finance, cutting stock problems in manufacturing.\nThe illustrative picture is the following: For a given a set of items with different weigths and values, you want to pack your knappsack with items such that the capacity of the knappsack is not exceeded and the total value of packed items is maximised.\nAs there exists different variants we start with one of the easiest ones:"
  },
  {
    "objectID": "20230710_garden/01_knappsack.html#sets",
    "href": "20230710_garden/01_knappsack.html#sets",
    "title": "knappsack problem",
    "section": "sets",
    "text": "sets\n\n\\(I\\), set of items \\(i\\)"
  },
  {
    "objectID": "20230710_garden/01_knappsack.html#decision-variables",
    "href": "20230710_garden/01_knappsack.html#decision-variables",
    "title": "knappsack problem",
    "section": "(decision) variables",
    "text": "(decision) variables\n\n\\(x_i\\), binary, 1 iff item \\(i\\) is put into knappsack"
  },
  {
    "objectID": "20230710_garden/01_knappsack.html#parameter",
    "href": "20230710_garden/01_knappsack.html#parameter",
    "title": "knappsack problem",
    "section": "parameter",
    "text": "parameter\n\n\\(v_i\\) value of item \\(i\\)\n\\(w_i\\) weight of item \\(i\\)\n\\(W\\) capacity of knappsack"
  },
  {
    "objectID": "20230710_garden/01_knappsack.html#pyomo-implementation",
    "href": "20230710_garden/01_knappsack.html#pyomo-implementation",
    "title": "knappsack problem",
    "section": "pyomo implementation",
    "text": "pyomo implementation\n\nimport pyomo.environ as pyo\nimport pandas as pd\nimport numpy as np\n\n\n# model\n\ndef knappsack_01(data):\n    pdata = data['problem_data']\n    \n    m = pyo.ConcreteModel(data['model_name'])\n    \n    ## sets\n    m.Item = pyo.Set(initialize = list(pdata['items']), \n                     doc = 'list of items')\n    # var\n    m.x = pyo.Var(m.Item, domain = pyo.Binary, \n                  doc = '1 if item is part of knappsack')\n    ## param\n    @m.Param(m.Item, doc ='value of item i')\n    def value(m,i):\n        return pdata.loc[pdata['items'] == i,'values'].values[0]\n    \n    @m.Param(m.Item, doc ='weight of item i')\n    def weight(m,i):\n        return pdata.loc[pdata['items'] == i,'weights'].values[0]\n    \n    @m.Param(doc = 'capacity limit')\n    def cap_limit(m):\n        return list(pdata['capacity'].unique())[0]\n    \n    ## objective\n    m.OBJ = pyo.Objective(expr = sum(m.value[i] * m.x[i] for i in m.Item), sense = pyo.maximize)\n    \n    ## constraints\n    @m.Constraint(doc = 'knappsack capacity limit')\n    def c1(m):\n        return sum(m.weight[i] * m.x[i] for i in m.Item) <= m.cap_limit\n    \n    solver = pyo.SolverFactory(data['solver'])\n    solver.solve(m)\n    \n    return m"
  },
  {
    "objectID": "20230710_garden/01_knappsack.html#simple-example",
    "href": "20230710_garden/01_knappsack.html#simple-example",
    "title": "knappsack problem",
    "section": "simple example",
    "text": "simple example\n\n# data\nitems = ['a','b','c','d']\nvalues = [8,3,6,11]\nweights= [5,7,4,3]\ncapacity_limit = 14\n\ndf = pd.DataFrame(\n    {'items' : items,\n     'values' : values,\n     'weights' : weights},\n    )\ndf['capacity'] = capacity_limit\n\ndisplay(df)\n\ndata = {\n    'model_name': 'bounded_knappsack',\n    'problem_data' : df,\n    'solver': 'cbc'\n}\n\n\n\n\n\n  \n    \n      \n      items\n      values\n      weights\n      capacity\n    \n  \n  \n    \n      0\n      a\n      8\n      5\n      14\n    \n    \n      1\n      b\n      3\n      7\n      14\n    \n    \n      2\n      c\n      6\n      4\n      14\n    \n    \n      3\n      d\n      11\n      3\n      14\n    \n  \n\n\n\n\n\nm = knappsack_01(data)\n\n\ndef extract_solution(m):\n    solution = {r: [pyo.value(m.x[r])==1.0] for r in m.Item}\n    output = pd.DataFrame(data = solution)\n    output.index = ['object in knappsack']\n    return output\n\n\nextract_solution(m)\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n      d\n    \n  \n  \n    \n      object in knappsack\n      True\n      False\n      True\n      True"
  },
  {
    "objectID": "20220621_jobshop/02_sugar_can_production.html",
    "href": "20220621_jobshop/02_sugar_can_production.html",
    "title": "Blending models - Sugar cane production",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport numpy as np\nimport pyomo.environ as pyo\nfrom math import ceil"
  },
  {
    "objectID": "20220621_jobshop/02_sugar_can_production.html#problem-description",
    "href": "20220621_jobshop/02_sugar_can_production.html#problem-description",
    "title": "Blending models - Sugar cane production",
    "section": "Problem description",
    "text": "Problem description\nBecause sugar cane decreases rapidly trough fermentation, harvested sugar cane is transported to a sugar house in wagons on rail network for further processing immediately.\nSuppose we have 11 wagons with sugar, all loaded with the same quantity. Moreover we know the hourly loss of sugar in kg per hour and the remaining live span in hour of the lot in every wagon. (see table below)\nSuppose further that we have 3 equivalent production lines in the sugar house to process the lot and that processing a lot takes two hours. Moreover the processing must be finished at latest at the end of the life span of the wagon load.\nWe are asked to determine a production schedule for the currently available lots that minimizes the total loss of sugar."
  },
  {
    "objectID": "20220621_jobshop/02_sugar_can_production.html#remarks",
    "href": "20220621_jobshop/02_sugar_can_production.html#remarks",
    "title": "Blending models - Sugar cane production",
    "section": "Remarks",
    "text": "Remarks\nThis example is from [@gueret1999applications, chap. 6.4].\nWe give\n\nthe algebraic model formulation\nan implemetation in pyomo\ngive an optimal solution\n\n\n\nCode\ndata = {\n    'lot':{\n        1:{'loss': 43, 'life_span': 8},\n        2:{'loss': 26, 'life_span': 8},\n        3:{'loss': 37, 'life_span': 2},\n        4:{'loss': 28, 'life_span': 8},\n        5:{'loss': 13, 'life_span': 4},\n        6:{'loss': 54, 'life_span': 8},\n        7:{'loss': 62, 'life_span': 8},\n        8:{'loss': 49, 'life_span': 8},\n        9:{'loss': 19, 'life_span': 8},\n        10:{'loss': 28, 'life_span':8},\n        11:{'loss': 30, 'life_span':8},  \n    },\n    'number_of_production_lines':3,\n    'processing time in h': 2\n\n}\n\n\n\n\nCode\npd.DataFrame(data['lot'])\n\n\n\n\n\n\n  \n    \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n    \n  \n  \n    \n      loss\n      43\n      26\n      37\n      28\n      13\n      54\n      62\n      49\n      19\n      28\n      30\n    \n    \n      life_span\n      8\n      8\n      2\n      8\n      4\n      8\n      8\n      8\n      8\n      8\n      8"
  },
  {
    "objectID": "20220621_jobshop/02_sugar_can_production.html#sets",
    "href": "20220621_jobshop/02_sugar_can_production.html#sets",
    "title": "Blending models - Sugar cane production",
    "section": "sets",
    "text": "sets\n\n\\(wagons = \\{1,\\ldots,NW\\}\\) set of wagons"
  },
  {
    "objectID": "20220621_jobshop/02_sugar_can_production.html#variables",
    "href": "20220621_jobshop/02_sugar_can_production.html#variables",
    "title": "Blending models - Sugar cane production",
    "section": "variables",
    "text": "variables"
  },
  {
    "objectID": "20220621_jobshop/02_sugar_can_production.html#parameter",
    "href": "20220621_jobshop/02_sugar_can_production.html#parameter",
    "title": "Blending models - Sugar cane production",
    "section": "parameter",
    "text": "parameter\n\nNL number of production lines\nNW number of wagons\nNS maximal number of time slots\n\n\n\nCode\ndef model(data):\n    m = pyo.ConcreteModel('sugar cane production')\n    \n    # sets and param\n    m.wagons = pyo.Set(initialize = data['lot'].keys(), \n                       doc = \"set of wagon w\")\n    \n    m.NW = pyo.Param(initialize = max(list(data['lot'].keys())),\n                     doc = \"number of wagons\")\n    m.NL = pyo.Param(initialize = data['number_of_production_lines'],\n                     doc = \"number of production lines\")\n    m.NS = pyo.Param(initialize = ceil(m.NW / m.NL), \n                    doc = \"maximal number of time slots\")\n    m.slots = pyo.RangeSet(1,m.NS)\n    m.duration = pyo.Param(initialize = data['processing time in h'],\n                          doc = 'processing time per lot in h')\n    \n    @m.Param(m.wagons,doc = \"hourly loss of wagon w\")\n    def loss(m,w):\n        return data['lot'][w]['loss']\n    @m.Param(m.wagons,doc = \"life span of wagon w\")\n    def life(m,w):\n        return data['lot'][w]['life_span']\n    \n    # var\n    m.process = pyo.Var(m.wagons, m.slots, domain = pyo.Binary,\n                        doc = \"1 iff wagon w is assigned to slot s\")\n    \n    # constraints\n    @m.Constraint(m.wagons, doc = \"each wagon is assigned to one slot\")\n    def c1(m,w):\n        return pyo.quicksum(m.process[w,s] for s in m.slots) == 1\n    @m.Constraint(m.slots, doc = \"each slot can take maximal NL lots\")\n    def c2(m,s):\n        return pyo.quicksum(m.process[w,s] for w in m.wagons) <= m.NL\n    @m.Constraint(m.wagons, doc = 'life span bound per lot')\n    def c3(m,w):\n        return pyo.quicksum(m.slots[s] * m.process[w,s] for s in m.slots) <= m.life[w] / m.duration\n    \n    m.OBJ = pyo.Objective(expr = pyo.quicksum(s * m.duration * m.loss[w] * m.process[w,s] \n                                             for s in m.slots for w in m.wagons),\n                          sense = pyo.minimize,\n                         doc = 'minimize loss of sugar')\n    \n    # choose and apply solver\n    solver = pyo.SolverFactory('glpk')\n    solver.solve(m)    \n    \n    return m\n\n\n\n\nCode\nm = model(data)\n\nprint('lost sugar' +str(pyo.value(m.OBJ)))\n\nsolution = {\n    'assignment': {'lot_'+ str(w): 'slot_' + str(s) for w in m.wagons for s in m.slots if pyo.value(m.process[w,s]) != 0.}\n}\n\nsolution\n\n\nWARNING: DEPRECATED: Using __getitem__ to return a set value from its\n    (ordered) position is deprecated.  Please use at()  (deprecated in 6.1,\n    will be removed in (or after) 7.0) (called from <ipython-\n    input-4-72c7b297ba04>:38)\nlost sugar1602.0\n\n\n{'assignment': {'lot_1': 'slot_2',\n  'lot_2': 'slot_4',\n  'lot_3': 'slot_1',\n  'lot_4': 'slot_3',\n  'lot_5': 'slot_2',\n  'lot_6': 'slot_1',\n  'lot_7': 'slot_1',\n  'lot_8': 'slot_2',\n  'lot_9': 'slot_4',\n  'lot_10': 'slot_3',\n  'lot_11': 'slot_3'}}\n\n\n\n\nCode\npd.DataFrame(solution)\n\n\n\n\n\n\n  \n    \n      \n      assignment\n    \n  \n  \n    \n      lot_1\n      slot_2\n    \n    \n      lot_10\n      slot_3\n    \n    \n      lot_11\n      slot_3\n    \n    \n      lot_2\n      slot_4\n    \n    \n      lot_3\n      slot_1\n    \n    \n      lot_4\n      slot_3\n    \n    \n      lot_5\n      slot_2\n    \n    \n      lot_6\n      slot_1\n    \n    \n      lot_7\n      slot_1\n    \n    \n      lot_8\n      slot_2\n    \n    \n      lot_9\n      slot_4"
  },
  {
    "objectID": "20221127_jupyter_test/index.html",
    "href": "20221127_jupyter_test/index.html",
    "title": "Pyomo and solver test",
    "section": "",
    "text": "We give the implementation of a simple model in pyomo to test the correct installation and in particular the solvers.\nExpectation: code is executed without errors\n\n\nconda env create -f environment.yml\nconda activate blog\n\nimport pyomo.environ as pyo\n\n\nmodel = pyo.ConcreteModel()\n\nmodel.x = pyo.Var([1,2], domain=pyo.NonNegativeReals)\n\nmodel.OBJ = pyo.Objective(expr = 2*model.x[1] + 3*model.x[2])\n\nmodel.Constraint1 = pyo.Constraint(expr = 3*model.x[1] + 4*model.x[2] >= 1)\n\n\nglpk_test = pyo.SolverFactory('glpk')\ncbc_test = pyo.SolverFactory('cbc')\nipopt_test = pyo.SolverFactory('ipopt')\n\n\nglpk_test.solve(model)\n\n{'Problem': [{'Name': 'unknown', 'Lower bound': 0.666666666666667, 'Upper bound': 0.666666666666667, 'Number of objectives': 1, 'Number of constraints': 2, 'Number of variables': 3, 'Number of nonzeros': 3, 'Sense': 'minimize'}], 'Solver': [{'Status': 'ok', 'Termination condition': 'optimal', 'Statistics': {'Branch and bound': {'Number of bounded subproblems': 0, 'Number of created subproblems': 0}}, 'Error rc': 0, 'Time': 0.013138532638549805}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value             : Upper : Fixed : Stale : Domain\n          1 :     0 : 0.333333333333333 :  None : False : False : NonNegativeReals\n          2 :     0 :               0.0 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1\n\n\n\ncbc_test.solve(model)\n\n{'Problem': [{'Name': 'unknown', 'Lower bound': 0.6666666667, 'Upper bound': 0.6666666667, 'Number of objectives': 1, 'Number of constraints': 2, 'Number of variables': 3, 'Number of nonzeros': 0, 'Sense': 'minimize'}], 'Solver': [{'Status': 'ok', 'User time': -1.0, 'System time': 0.0, 'Wallclock time': 0.0, 'Termination condition': 'optimal', 'Termination message': 'Model was solved to optimality (subject to tolerances), and an optimal solution is available.', 'Statistics': {'Branch and bound': {'Number of bounded subproblems': None, 'Number of created subproblems': None}, 'Black box': {'Number of iterations': 0}}, 'Error rc': 0, 'Time': 0.04025125503540039}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value      : Upper : Fixed : Stale : Domain\n          1 :     0 : 0.33333333 :  None : False : False : NonNegativeReals\n          2 :     0 :        0.0 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1\n\n\n\nipopt_test.solve(model)\n\n{'Problem': [{'Lower bound': -inf, 'Upper bound': inf, 'Number of objectives': 1, 'Number of constraints': 1, 'Number of variables': 2, 'Sense': 'unknown'}], 'Solver': [{'Status': 'ok', 'Message': 'Ipopt 3.14.11\\\\x3a Optimal Solution Found', 'Termination condition': 'optimal', 'Id': 0, 'Error rc': 0, 'Time': 0.05022311210632324}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value                   : Upper : Fixed : Stale : Domain\n          1 :     0 :      0.3333333343972087 :  None : False : False : NonNegativeReals\n          2 :     0 : -2.3599945501636825e-09 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1"
  },
  {
    "objectID": "20230308_scip/01_SCIP_install.html",
    "href": "20230308_scip/01_SCIP_install.html",
    "title": "SCIP - fast non-commercial solver got open source licence",
    "section": "",
    "text": "summary\nWe saw the basic components of pyscipopt in order to create an optimization model. In the following notebooks we will look at some classical problems and how to solve them using SCIP.\n\n\n\n\n\nFootnotes\n\n\nhttps://www.scipopt.org/doc-8.0.3/html/↩︎"
  },
  {
    "objectID": "20230308_scip/02_SCIP_transport_problem.html",
    "href": "20230308_scip/02_SCIP_transport_problem.html",
    "title": "Transport problems with SCIP",
    "section": "",
    "text": "Suppose you can produce goods in different factories and sell them on different markets. Each factory has its own production capacity and each market has its own demand, which we may know after elaborating a survey. As the distances of the markets and the factories are different, we are looking for a transport route which minimizes the total costs.\nThe problem can be visualized as follows\n\n\n\nTransportProblem\n\n\nReference: [@scipbook, introduction:Transport problem]\n\n\nAgain we assume that the reader is familiar with basic concepts of optimization, but we are writting the blog in a way that the unexperienced readers see the benefit of these techniques, while considering them as blakc boxes.\n\nSCIP multidic\nget slack variable values, sensitivity analysis, shadow prices, … (all synonyms)"
  },
  {
    "objectID": "20230308_scip/02_SCIP_transport_problem.html#sets",
    "href": "20230308_scip/02_SCIP_transport_problem.html#sets",
    "title": "Transport problems with SCIP",
    "section": "Sets",
    "text": "Sets\n\n\\(I\\) customer set\n\\(J\\) factory set"
  },
  {
    "objectID": "20230308_scip/02_SCIP_transport_problem.html#variables",
    "href": "20230308_scip/02_SCIP_transport_problem.html#variables",
    "title": "Transport problems with SCIP",
    "section": "Variables",
    "text": "Variables\n\n\\(x_{i,j}\\) amount of goods transported from factory \\(j\\) to customer \\(i\\)"
  },
  {
    "objectID": "20230308_scip/02_SCIP_transport_problem.html#parameter",
    "href": "20230308_scip/02_SCIP_transport_problem.html#parameter",
    "title": "Transport problems with SCIP",
    "section": "Parameter",
    "text": "Parameter\n\n\\(c_{i,j}\\) transportation costs from factory \\(i\\) to customer \\(j\\)\n\\(d_i\\) demand of customer \\(i\\)\n\\(m_j\\) production capacity of factory \\(j\\)"
  },
  {
    "objectID": "20230308_scip/02_SCIP_transport_problem.html#lp-model",
    "href": "20230308_scip/02_SCIP_transport_problem.html#lp-model",
    "title": "Transport problems with SCIP",
    "section": "LP-Model",
    "text": "LP-Model\n\\[\n\\begin{array}{llll}\n\\min & \\sum_{i,j} c_{i,j} x_{i,j} & & \\\\\ns.t. & \\sum_j x_{i,j}             & = d_i & \\forall i\\\\\n     & \\sum_i x_{i,j}             & \\leq m_j & \\forall j\\\\\n     & x_{i,j}                    & \\geq 0 & \\forall i,j\n\\end{array}\n\\]\n\nimport pyscipopt as scip\n\n\n# demand\nI, d = scip.multidict({1:80, 2:270, 3:250, 4:160, 5:180})\n# capacities\nJ, M = scip.multidict({1:500, 2:500, 3:500})\n\n\n# transport costs\nc = {(1,1):4,    (1,2):6,    (1,3):9,\n     (2,1):5,    (2,2):4,    (2,3):7,\n     (3,1):6,    (3,2):3,    (3,3):3,\n     (4,1):8,    (4,2):5,    (4,3):3,\n     (5,1):10,   (5,2):8,    (5,3):4,\n     }\n\n\nm = scip.Model()   \n\n# variables\nx = {}\nfor i in I:\n    for j in J:\n        x[i,j] = m.addVar(vtype = 'C', name = 'x(%s,%s)' % (i,j))\n    \n# constraints\nfor i in I:\n    m.addCons(scip.quicksum( x[i,j] for j in J if (i,j) in x) == d[i],\n              name = 'CustomerDemand(%s)' % i)\nfor j in J:\n    m.addCons(scip.quicksum( x[i,j] for i in I if (i,j) in x) <= M[j],\n              name = 'FactoryCapacity(%s)' % j)\n    \n# objective\nm.setObjective(scip.quicksum(c[i,j]*x[i,j] for (i,j) in x),\n               sense = 'minimize')   \n\nm.optimize()    \n\n\nprint(\"optimal value:\", m.getObjVal())\nepsilon = 1.e-6\nfor (i,j) in x:\n    if m.getVal(x[i,j]) > epsilon:\n        print('send %10s goods from factory %2s to customer %2s' % (m.getVal(x[i,j]), j, i))\n\noptimal value: 3350.0\nsend       80.0 goods from factory  1 to customer  1\nsend      270.0 goods from factory  2 to customer  2\nsend      230.0 goods from factory  2 to customer  3\nsend       20.0 goods from factory  3 to customer  3\nsend      160.0 goods from factory  3 to customer  4\nsend      180.0 goods from factory  3 to customer  5"
  },
  {
    "objectID": "20230308_scip/02_SCIP_transport_problem.html#example-continued",
    "href": "20230308_scip/02_SCIP_transport_problem.html#example-continued",
    "title": "Transport problems with SCIP",
    "section": "Example continued",
    "text": "Example continued\nSuppose you believe your factory capacity got tight and you are considering an expansion and you ask yourself the following questions:\n\nWhat kind of costs can be reduced by expanding each factory?\nWhat is the additional profit you can make if you get additional orders from each customer?\n\nIn order to investigate whether or not a factory should be expanded, we look at the values of the slack variables of the capacity constraints:\n\\[\n\\sum_i x_{i,j}\\leq M_j\n\\]\nWe recall that \\(x_{i,j}\\) denotes the amount of goods transported from factory \\(j\\) to market \\(i\\) and \\(M_j\\) denotes the capacity of factory \\(j\\)."
  },
  {
    "objectID": "20230308_scip/03_multicommodity_transportProblem.html",
    "href": "20230308_scip/03_multicommodity_transportProblem.html",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "",
    "text": "We generalize our transport problem to the case that we are producing multiple commodities in our factories. Again each factory has its own production capacity and the markets have their own demand for each commodity. Moreover the transport costs depends on the commodity.\n\n\n\njson file as data input"
  },
  {
    "objectID": "20230308_scip/03_multicommodity_transportProblem.html#sets",
    "href": "20230308_scip/03_multicommodity_transportProblem.html#sets",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "sets",
    "text": "sets\n\n\\(I\\) customer\n\\(J\\) factory\n\\(K\\) commodity"
  },
  {
    "objectID": "20230308_scip/03_multicommodity_transportProblem.html#variables",
    "href": "20230308_scip/03_multicommodity_transportProblem.html#variables",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "variables",
    "text": "variables\n\n\\(x_{i,j,k}\\) transported amount of commodity \\(k\\) form factory \\(j\\) to customer \\(i\\)"
  },
  {
    "objectID": "20230308_scip/03_multicommodity_transportProblem.html#parameters",
    "href": "20230308_scip/03_multicommodity_transportProblem.html#parameters",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "parameters",
    "text": "parameters\n\n\\(c_{i,j,k}\\) transport costs of commodity \\(k\\) form factory \\(j\\) to customer \\(i\\)\n\\(d_{i,k}\\) demand of commodity \\(k\\) in market \\(i\\)\n\\(M_j\\) capacity of factory \\(j\\)"
  },
  {
    "objectID": "20230308_scip/03_multicommodity_transportProblem.html#constraints",
    "href": "20230308_scip/03_multicommodity_transportProblem.html#constraints",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "constraints",
    "text": "constraints\n\n(c1) fulfill demand in each market\n(c2) do not exceed factory capacity"
  },
  {
    "objectID": "20230308_scip/03_multicommodity_transportProblem.html#objective",
    "href": "20230308_scip/03_multicommodity_transportProblem.html#objective",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "objective",
    "text": "objective\nMinimize total costs"
  },
  {
    "objectID": "20230308_scip/03_multicommodity_transportProblem.html#model",
    "href": "20230308_scip/03_multicommodity_transportProblem.html#model",
    "title": "Multi Commodoity transport problems with SCIP",
    "section": "model",
    "text": "model\n\\[\n\\begin{array}{lll}\n\\min & \\sum_{i,j,l} c_{i,j,k} x_{i,j,k} & \\\\\ns.t. & \\sum_j x_{i,j,k} = d_{i,k} & \\forall i,k \\\\\n     & \\sum_{i,k} x_{i,j,k} \\leq M_j & \\forall j \\\\\n     & x_{i,j,k} \\leq 0 &\n\\end{array}\n\\]\n\nimport pyscipopt as scip\nimport json\n\n\ndata = {\n    \"Name\": \"multi-commodity transportation\",\n    \n    \"Engine\": \"\",\n    \"TimeLimit\": \"\"\n\n}\n\n\n# data\nJ,M = scip.multidict({1:3000, 2:3000, 3:3000})\nproduce = {1:[2,4], 2:[1,2,3], 3:[2,3,4]}\n\nd = {(1,1):80,   (1,2):85,   (1,3):300,  (1,4):6,\n     (2,1):270,  (2,2):160,  (2,3):400,  (2,4):7,\n     (3,1):250,  (3,2):130,  (3,3):350,  (3,4):4,\n     (4,1):160,  (4,2):60,   (4,3):200,  (4,4):3,\n     (5,1):180,  (5,2):40,   (5,3):150,  (5,4):5\n     }\nI = set([i for (i,k) in d])\nK = set([k for (i,k) in d])\n\nweight = {1:5, 2:2, 3:3, 4:4}\ncost = {(1,1):4,  (1,2):6, (1,3):9,\n        (2,1):5,  (2,2):4, (2,3):7,\n        (3,1):6,  (3,2):3, (3,3):4,\n        (4,1):8,  (4,2):5, (4,3):3,\n        (5,1):10, (5,2):8, (5,3):4\n        }\nc = {}\nfor i in I:\n    for j in J:\n        for k in produce[j]:\n            c[i, j, k] = cost[i,j] * weight[k]\n\n\ndef MultiCommoditityTransportation(I,J,K, c,d,M):\n    \n    model = scip.Model()\n    # vars\n    x = {}\n    for i in I:\n        for j in J:\n            for k in K:\n                x[i,j,k] = model.addVar(vtype = 'C',\n                                       name = 'x(%s,%s,%s)' %  (i,j,k))\n                \n    # constraints\n    for j in J:\n        model.addCons(scip.quicksum(x[i,j,k] for (i,j_,k) in x if j_ == j) <= M[j],\n                      name = 'FactoryCapacity(%s)' % j)\n        \n    for i in I:\n        for k in K:\n            model.addCons(scip.quicksum(x[i,j,k] for j in J if (i,j,k) in x) == d[i,k]\n            )\n\n    # objective\n    model.setObjective(scip.quicksum(c[i,j,k] * x[i,j,k]  for (i,j,k) in c),\n                      sense = 'minimize')\n    \n    # for post processing\n    model.data = x\n    \n    return model\n\n\nm = MultiCommoditityTransportation(I,J,K, c,d,M)\nm.optimize()\n\n\nprint('optimal value:', m.getObjVal())\nepsilon =1.e-6\nx = m.data\nfor (i,j,k) in x:\n    if m.getVal(x[i,j,k]) >= epsilon:\n        print('send %10s of commodity %3s from factory %3s to customer %3s' % (m.getVal(x[i,j,k]), k, j, i))\n\noptimal value: 3420.0\nsend       85.0 of commodity   2 from factory   1 to customer   1\nsend      300.0 of commodity   3 from factory   1 to customer   1\nsend        6.0 of commodity   4 from factory   2 to customer   1\nsend       80.0 of commodity   1 from factory   3 to customer   1\nsend      400.0 of commodity   3 from factory   1 to customer   2\nsend      160.0 of commodity   2 from factory   2 to customer   2\nsend        7.0 of commodity   4 from factory   2 to customer   2\nsend      270.0 of commodity   1 from factory   3 to customer   2\nsend      350.0 of commodity   3 from factory   1 to customer   3\nsend      130.0 of commodity   2 from factory   2 to customer   3\nsend        4.0 of commodity   4 from factory   2 to customer   3\nsend      250.0 of commodity   1 from factory   3 to customer   3\nsend      200.0 of commodity   3 from factory   1 to customer   4\nsend        3.0 of commodity   4 from factory   2 to customer   4\nsend      160.0 of commodity   1 from factory   3 to customer   4\nsend       60.0 of commodity   2 from factory   3 to customer   4\nsend      150.0 of commodity   3 from factory   1 to customer   5\nsend        5.0 of commodity   4 from factory   2 to customer   5\nsend      180.0 of commodity   1 from factory   3 to customer   5\nsend       40.0 of commodity   2 from factory   3 to customer   5"
  },
  {
    "objectID": "20230717_ORTools/01_intro_ORTools.html",
    "href": "20230717_ORTools/01_intro_ORTools.html",
    "title": "OR-Tools",
    "section": "",
    "text": "Multiple solutions\nIn the previous setting there was only one solution due to the choice of the upper bound, i.e. maximal 10000 soldiers in teh army.\n\n\nCode\ndata['army_ub'] = 100000\n\n\n\n\nCode\nchinese_remainder(data)\n\n\nsolution time 0.003 milliseconds\nsoldiers in enemy army: 9139\n\n\n9139"
  },
  {
    "objectID": "20230717_ORTools/03_basic_operations_CP_SAT.html",
    "href": "20230717_ORTools/03_basic_operations_CP_SAT.html",
    "title": "CP-SAT basic operations",
    "section": "",
    "text": "this is just a collection of working code snippets to show basic operations when using OR-Tools\nc.f. github OR-tools for more details\n\n\n\nin order to have running code we use the chinese remainder theorem as a simple example, i.e. determine the remainder of the division of a given number of (coprime) divisors.\n\n\nCode\nfrom ortools.sat.python import cp_model\n\n\n\n\nCode\ndata = {\n    'army_ub': 10000,\n    'counts': [13,19,37]\n}\n\n\n\n\nCode\n# instantiate the model and the solver\nmodel = cp_model.CpModel()\nsolver = cp_model.CpSolver()\n# declare variable (together with bounds)\narmy = model.NewIntVar(1, data['army_ub'], 'army')\n# declare constraints\nfor i in data['counts']:\n    model.AddModuloEquality(0, army, i)\n# apply solver\nstatus = solver.Solve(model)  \nif status == cp_model.OPTIMAL:\n    print(\"solution time %s milliseconds\" %round(solver.WallTime(), 3))\n    print(\"soldiers in enemy army: %s\" %solver.Value(army))\n\n\nsolution time 0.007 milliseconds\nsoldiers in enemy army: 9139\n\n\n\n\nIn the example we assumed that the upper bound for variable army eguals 10000. The following snippet shows, how to change a variable bound\n\n\nCode\nnew_value = 100000\narmy.Proto().domain[:] = []\narmy.Proto().domain.extend(cp_model.Domain(1, new_value).FlattenedIntervals())\narmy.Proto()\n\n\nname: \"army\"\ndomain: 1\ndomain: 100000\n\n\n\n\nCode\nclass CallbackSolutionPrinter(cp_model.CpSolverSolutionCallback):\n    \"\"\"Print all solutions.\"\"\"\n\n    def __init__(self, variable):\n        cp_model.CpSolverSolutionCallback.__init__(self)\n        self.__variable = variable\n\n    def on_solution_callback(self):\n        print(self.Value(self.__variable))\n\n\n\n\nCode\nsolutionprinter = CallbackSolutionPrinter(army)\nsolver.parameters.enumerate_all_solutions = True\nsolver_status = solver.Solve(model, solutionprinter)\n\n\n9139\n18278\n27417\n36556\n45695\n54834\n63973\n73112\n82251\n91390"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "",
    "text": "In this post we explain certain tools to investigate how an optimal solution changes when the input data changes. First we will introduce the notions and study how to do it in pyomo with the help of a small example.\nOne usage of these tool could be: Suppose we have factories with certain capacities producing certain products. We used a linear program to derive an optimal solution how to use our resources best. In this optimal setting some factories will running at their capacity limit. Now suppose we want to produce/sell more, hence we have to increase the capacities. Hence a natural question is which capacities should be increased first. Of course we could do simmulations using our linear program, but with the help of what we will see soon these information are allready available with our optimal solution.\n\n\n\npyomo suffixes\nsensitivity analysis\naccessing duals\nreduced costs\nshadow prices\nslack values"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#sets",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#sets",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "sets",
    "text": "sets\n\n\\(type\\) - chip type\n\\(process\\) - production process"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#variables",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#variables",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "variables",
    "text": "variables\n\n\\(x_i\\) produced amount of chip type \\(i \\in type\\)"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#parameters",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#parameters",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "parameters",
    "text": "parameters\n\n\\(profit_i\\) - profit of 1 kg of type \\(i\\) chip in $\n\\(avail_j\\) - available time for production process \\(j\\)\n\\(time_{ij}\\) - required time in min for 1 kg of type \\(i\\) chip and production process \\(j\\)"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#constraints",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#constraints",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "constraints",
    "text": "constraints\n\n(c1) time restriction on slicing\n(c2) time restriction on frying\n(c3) time restriction on packing\nproduction quantities are not negative"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#objective",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#objective",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "objective",
    "text": "objective\nMaximize net profit"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#model",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#model",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "model",
    "text": "model\n\\[\n\\begin{array}{lll}\n\\max & \\sum_{i\\in type} profit_i \\cdot x_i & \\\\\ns.t. & \\sum_{i\\in type} time_{ij} \\cdot x_i \\leq avail_j & \\forall j\\in process \\\\\n     & x_{i} \\leq 0 &\n\\end{array}\n\\]\n\nimport pyomo.environ as pyo\nimport json\n\n\ndata = {\n    \"Name\": \"Chip Shop\",\n    \"constraints\": {\n        'slicing': {'plain': 2, 'mexican': 4, 'availibility': 345},\n        'frying': {'plain': 4, 'mexican': 5, 'availibility': 480},\n        'packing': {'plain': 4, 'mexican': 2, 'availibility': 330},\n    },\n    \"profit\": {'plain': 2., 'mexican': 1.5},\n    \"Engine\": \"cbc\",\n    \"TimeLimit\": \"\"\n\n}"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#interlude-accessing-duals-in-pyomo",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#interlude-accessing-duals-in-pyomo",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "Interlude accessing duals in Pyomo",
    "text": "Interlude accessing duals in Pyomo\nIn order to extract the desired information we are using suffixes in pyomo. Suffixes provide a mechanism for declaring extraneous model data, which can be used in a number of contexts. The following code snippet shows how to declare a suffix component:\nm.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)"
  },
  {
    "objectID": "SensitivityAnalysis/01_sensitivity_analysis.html#chips-model",
    "href": "SensitivityAnalysis/01_sensitivity_analysis.html#chips-model",
    "title": "Sensitivity Analysis in Pyomo",
    "section": "chips model",
    "text": "chips model\n\ndef chip_shop(data):    \n    m = pyo.ConcreteModel(data['Name'])\n    \n    #sets\n    m.types = pyo.Set(initialize = list(data['profit'].keys()))\n    m.process = pyo.Set(initialize = list(data['constraints'].keys()))\n    \n    # decision variables\n    m.x = pyo.Var(m.types, domain = pyo.NonNegativeReals, doc = 'produced packages of chip type i')\n    \n    \n    \n    # parameter\n    @m.Param(m.types, m.process, doc = 'processing time of product i in process j')\n    def time(m,i,j):\n        return data['constraints'][j][i]\n    @m.Param(m.process, doc = 'available processing time for process j')\n    def avail(m,j):\n        return data['constraints'][j]['availibility']\n    @m.Param(m.types, doc = 'net profits for product i')\n    def profit(m,i):\n        return data['profit'][i]\n    \n    # objective\n    m.OBJ = pyo.Objective(expr = pyo.quicksum(m.profit[i] * m.x[i] for i in m.types),\n                         sense = pyo.maximize)\n    \n    # constraints\n    @m.Constraint(m.process)\n    def c(m,j):\n        return pyo.quicksum(m.time[i,j] * m.x[i] for i in m.types) <= m.avail[j]\n    \n    # declaring a Suffix component - to access duals, slack, etc.\n    m.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)\n    \n    #extra components for output\n    m.optimaltime = pyo.Var(m.process, domain = pyo.NonNegativeReals)\n    @m.Constraint(m.process)\n    def opttime(m,j):\n        return m.optimaltime[j] == pyo.quicksum(m.time[i,j] * m.x[i] for i in m.types)\n    \n    # choosing and applying a solver\n    solver = pyo.SolverFactory('cbc')\n    solver.solve(m)\n    \n    return m\n\n\nm = chip_shop(data)\nprint('objective value: %s' % pyo.value(m.OBJ))\nfor i in m.types:\n    print('%10s optimal production: %3s' % (i, pyo.value(m.x[i])))\n\nobjective value: 190.0\n     plain optimal production: 57.5\n   mexican optimal production: 50.0"
  },
  {
    "objectID": "assignment_problems/10_weapon_assignment_problem.html",
    "href": "assignment_problems/10_weapon_assignment_problem.html",
    "title": "Weapon target assignment problem",
    "section": "",
    "text": "According to the wikipedia article the about the weapon target assignnment problem (WTA) can be formulated as follows:\nGiven a number of weapons and a number of targets. The weapons are of type \\(i=1,\\ldots ,m\\) and \\(W_i\\) denotes the number available weapons of type \\(i\\). Similarly, there are \\(j=1,\\ldots ,n\\) targets with value \\(V_j\\). Any of the weapons can be assigned to any target. Each weapon type has a certain probability of destroying each target, given by \\(p_{ij}\\).\nRemark: as this is a non linear problem, we include a brief section about implementing non linear models in pyomo and some modeling tips for nlp."
  },
  {
    "objectID": "assignment_problems/10_weapon_assignment_problem.html#math-formulation",
    "href": "assignment_problems/10_weapon_assignment_problem.html#math-formulation",
    "title": "Weapon target assignment problem",
    "section": "math formulation",
    "text": "math formulation\nThe WTA can be formulated as a non linear integer programm as follows:\n\\[\n\\begin{array}{llc}\n\\min & \\sum_j (V_j \\prod_i q_{ij}^{x_{ij}}) & \\\\\ns.t. & \\sum_j x_{ij} \\leq W_i &, \\forall i \\\\\n     & x_{ij} \\in \\mathbb{N}\n\\end{array}\n\\]\n\nobjective\nminimizing the expected survival value or equivalently maximizing the expeced damange\n\n\n(decision) variable\n\n\\(x_{ij}\\) is the number of weapons of type \\(i\\) assigned to target \\(j\\)\n\n\n\nparameter\n\n\\(p_{ij}\\) chance that one weapon \\(i\\) destroys target \\(j\\)\n\\(q_{ij}:=(1-p_{ij})\\) survival probability of target \\(j\\) for weapon \\(i\\)\n\n\n\nconstraints\nDont assign more weapons of type \\(i\\) than available, i.e. \\(W_i\\)\n\n\nassumptions\nwe see that the model uses statistical independency of the target survival probability, when multiple weapons are assigned.\n\n\nCode\nimport pyomo.environ as pyo\nimport pandas as pd\nimport numpy as np\nfrom itertools import product"
  },
  {
    "objectID": "assignment_problems/10_weapon_assignment_problem.html#example",
    "href": "assignment_problems/10_weapon_assignment_problem.html#example",
    "title": "Weapon target assignment problem",
    "section": "example",
    "text": "example\nWe consider the following example (from the wikipedia on the weapon target assignment problem)\n\n\nCode\ndata = {\n'problem_data' : {\n    'weapon_num': {'ground':5,'air':2, 'sea':1},\n    'target_val': {'T1':5,'T2':10,'T3':20},\n    'success_probability': pd.DataFrame(data = {'T1':[0.3,0.1,0.4],\n                                                'T2':[0.2,0.6,0.5], \n                                                'T3':[0.5,0.5,0.4]},\n                                        index = ['ground','air', 'sea'])\n},\n    'model_name': 'weapon assignment problem',\n    'solver': 'scip'\n}\n# for easier handling assign\ndaten = data['problem_data']\n\n\n\n\nCode\nprint('Given weapons and their availibility:')\ndaten['weapon_num']\n\n\nGiven weapons and their availibility:\n\n\n{'ground': 5, 'air': 2, 'sea': 1}\n\n\n\n\nCode\nprint('Given targets and their value:')\ndaten['target_val']\n\n\nGiven targets and their value:\n\n\n{'T1': 5, 'T2': 10, 'T3': 20}\n\n\n\n\nCode\nprint('success probabilities:')\ndisplay(daten['success_probability'])\n\n\nsuccess probabilities:\n\n\n\n\n\n\n  \n    \n      \n      T1\n      T2\n      T3\n    \n  \n  \n    \n      ground\n      0.3\n      0.2\n      0.5\n    \n    \n      air\n      0.1\n      0.6\n      0.5\n    \n    \n      sea\n      0.4\n      0.5\n      0.4"
  },
  {
    "objectID": "assignment_problems/10_weapon_assignment_problem.html#implementation",
    "href": "assignment_problems/10_weapon_assignment_problem.html#implementation",
    "title": "Weapon target assignment problem",
    "section": "Implementation",
    "text": "Implementation\nAs the used model for the weapon assignment problem is nonlinear lets recall:\n\nPyomo expression for non linear models\nWrite down a non linear problem in pyomo is easy:\n\n\n\noperation\noperator\nexample\n\n\n\n\nmultiplication\n*\nexpr = model.x * model.y\n\n\ndivision\n/\nexpr = model.x / model.y\n\n\nexponentiation\n**\nexpr = (model.x+2.0)**model.y\n\n\nin-place multiplication\n*=\nexpr *= model.x\n\n\nin-place division\n/=\nexpr = /= model.y\n\n\nin-place exponentiation\n**=\nexpr **= model.x\n\n\n\nmoreover there more supported functions part of the pyomo package, e.g. trigonometric functions:\n\nhttps://static1.squarespace.com/static/5492d7f4e4b00040889988bd/t/57bd0faad482e927298cca8f/1472008110099/5_Nonlinear.pdf\n\n\n\nSome modeling tips\n\nrecall many mathematical functions have a valid domain and evaluation outside of their domain caueses errors (-> bounds and innitilization)\nas solvers uses 1st and 2nd derivatives check bounds also w.r.t. derivatives ,e.g. for \\(f(x)=\\sqrt{x}\\) we have \\(f(0)\\) is valid but \\(\\frac{\\partial}{\\partial_x}f(0)\\) is not\nscale model to avoid variables, contraints, derivatives with different scales\n\n\n\nimplementation remark\n\nsolver supports minlp\nSome Sovlers can handle MINLPs like SCIP, hence after defining an non linear model in pyom, we can solve it as it were a linear model\n# define model\nmodel = pyo.ConcreteModel()\n...\n# choose solver an apply it\nsolver = pyo.SolverFactor('scip')\nsolver.solve(model)\nBut Pyomo comes with MindtPy a mixed-integer nonlinear decomposition toolbox, which allows using decomposition algorithms to solve MINLP. (c.f. upcomming blog post)\n\n\nusing decomposition algorithms from MindtPy\nsolver = pyo.SolverFactory('mindtpy')\nsolver.solve(model, mip_solver='glpk', nlp_solver='ipopt') \nreference: https://pyomo.readthedocs.io/en/stable/contributed_packages/mindtpy.html\n\n\nCode\ndef wta_scip(data):\n    # assign data to more handleble structures\n    daten = data['problem_data']\n    probs = daten['success_probability']\n    \n    # create model instance\n    m = pyo.ConcreteModel(data['model_name'])\n    \n    # sets\n    m.I = pyo.Set(initialize = daten['weapon_num'].keys(), doc = 'weapon types')\n    m.J = pyo.Set(initialize = daten['target_val'].keys(),doc = 'targets')\n    # decision variable\n    m.x = pyo.Var(m.I, m.J, domain = pyo.NonNegativeIntegers,\n                  doc = 'number of weapons of type i assigned to target j')\n    # parameter\n    @m.Param(m.I, doc = 'upper limit for weapon type i')\n    def W(m,i):\n        return daten['weapon_num'][i]\n    @m.Param(m.J, doc = 'target value')\n    def V(m,j):\n        return daten['target_val'][j]\n    @m.Param(m.I, m.J, doc = 'sucess probability when assign weapon i to target j')\n    def p(m,i,j):\n        return probs.loc[probs.index == i, j].values[0]\n    @m.Param(m.I, m.J, doc = 'survival probability (1-p_ij)')\n    def q(m,i,j):\n        return 1 - m.p[i,j]\n    \n    # constraints\n    @m.Constraint(m.I, doc = 'available number of weapons of type i')\n    def c1(m,i):\n        return m.W[i] >= pyo.quicksum(m.x[i,j] for j in m.J) \n    \n    # Objective\n    ## objective expression\n    m.objective = pyo.quicksum(m.V[j] * pyo.prod(m.q[i,j]**m.x[i,j] for i in m.I)  for j in m.J)\n    ## add objective to model\n    m.OBJ = pyo.Objective(expr = m.objective, sense = pyo.minimize)\n    \n    # define solver\n    solver = pyo.SolverFactory('scip')\n    solver.solve(m)\n    \n    return m\n\n\n\n\nCode\ndef wta(data):\n    # assign data to more handleble structures\n    daten = data['problem_data']\n    probs = daten['success_probability']\n    \n    # create model instance\n    m = pyo.ConcreteModel(data['model_name'])\n    \n    # sets\n    m.I = pyo.Set(initialize = daten['weapon_num'].keys(), doc = 'weapon types')\n    m.J = pyo.Set(initialize = daten['target_val'].keys(),doc = 'targets')\n    # decision variable\n    m.x = pyo.Var(m.I, m.J, domain = pyo.NonNegativeIntegers,\n                  doc = 'number of weapons of type i assigned to target j')\n    # parameter\n    @m.Param(m.I, doc = 'upper limit for weapon type i')\n    def W(m,i):\n        return daten['weapon_num'][i]\n    @m.Param(m.J, doc = 'target value')\n    def V(m,j):\n        return daten['target_val'][j]\n    @m.Param(m.I, m.J, doc = 'sucess probability when assign weapon i to target j')\n    def p(m,i,j):\n        return probs.loc[probs.index == i, j].values[0]\n    @m.Param(m.I, m.J, doc = 'survival probability (1-p_ij)')\n    def q(m,i,j):\n        return 1 - m.p[i,j]\n    \n    # constraints\n    @m.Constraint(m.I, doc = 'available number of weapons of type i')\n    def c1(m,i):\n        return m.W[i] >= pyo.quicksum(m.x[i,j] for j in m.J) \n    \n    # Objective\n    ## objective expression\n    m.objective = pyo.quicksum(m.V[j] * pyo.prod(m.q[i,j]**m.x[i,j] for i in m.I)  for j in m.J)\n    ## add objective to model\n    m.OBJ = pyo.Objective(expr = m.objective, sense = pyo.minimize)\n    \n    # define solver\n    pyo.SolverFactory('mindtpy').solve(m, mip_solver = 'cbc', nlp_solver = 'ipopt')\n    \n    return m\n\n\n\n\nCode\n#extract solution\ndef extract_solution(m):\n    df = pd.DataFrame(index = data['problem_data']['weapon_num'].keys(),\n                      columns = data['problem_data']['target_val'].keys())\n    for i,j in product(m.I,m.J):\n        df.at[i,j] = pyo.value(m.x[i,j])\n        \n    survival_value = pyo.value(m.OBJ)\n    return {'assignment': df, 'survival_value': survival_value}\n\n\n\n\nCode\n%%time\nm_scip = wta_scip(data)\n\n\nCPU times: user 41 ms, sys: 14.8 ms, total: 55.9 ms\nWall time: 139 ms\n\n\n\n\nCode\nprint('SCIP solution')\nextract_solution(m_scip)\n\n\nSCIP solution\n\n\n{'assignment':          T1   T2   T3\n ground  1.0  0.0  4.0\n air     0.0  2.0  0.0\n sea     1.0  0.0  0.0,\n 'survival_value': 4.95}\n\n\nLets look at the solution using mindtpy. Because we dont want to do understand mindtpy functionalities more deeply, we simply hardcoded to use cbc as mip solver and ipopt as nlp solver.\nin an upcoming blog we want to give a more details on the usages of mindtpy.\n\n\nCode\ndata['solver'] = 'cbc/ipopt'\n\n\n\n\nCode\n%%time\nm_cbc_ipopt = wta(data)\n\n\nERROR: Unable to clone Pyomo component attribute. Component 'I' contains an\n    uncopyable field '_init_values' (<class\n    'pyomo.core.base.set.TuplizeValuesInitializer'>).  Setting field to `None`\n    on new object\nERROR: Unable to clone Pyomo component attribute. Component 'J' contains an\n    uncopyable field '_init_values' (<class\n    'pyomo.core.base.set.TuplizeValuesInitializer'>).  Setting field to `None`\n    on new object\nCPU times: user 128 ms, sys: 103 ms, total: 231 ms\nWall time: 510 ms\n\n\n\n\nCode\nprint('cbc/ipopt solution')\nextract_solution(m_cbc_ipopt)\n\n\ncbc/ipopt solution\n\n\n{'assignment':          T1   T2   T3\n ground  1.0  0.0  4.0\n air     0.0  2.0  0.0\n sea     1.0  0.0  0.0,\n 'survival_value': 4.95}"
  },
  {
    "objectID": "assignment_problems/10_weapon_assignment_problem.html#summary",
    "href": "assignment_problems/10_weapon_assignment_problem.html#summary",
    "title": "Weapon target assignment problem",
    "section": "Summary",
    "text": "Summary\nWe saw how an non linear assigment problem can be implemented and solved using pyomo. We solved the MINLP in two ways: - using a solver which can be applied to MINLP directly - using the MINLP decomposition toolbox mindtpy, in our case using Coin-or branch and cut solver cbc “for the MIP” and the Interior Point OPTimizer ipopt “for the NLP”."
  }
]