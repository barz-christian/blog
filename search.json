[
  {
    "objectID": "20220928_github_actions/index.html",
    "href": "20220928_github_actions/index.html",
    "title": "github actions",
    "section": "",
    "text": "This post explains how to set up a CI/CD with GitHub Actions. It expands predefined nbdev workflows, such that non python packages can be used.\n\n\nGitHub Actions allows us to automate our build, test, and deployment pipeline by continuous integration and continuous delivery (CI/CD).\nWe can create workflows to build and test every pull request to our repository. Whenever an event occurs a workflow is triggered. A workflow contains one or more jobs. In other words: We specify in a workflow what (jobs) should be done when (event).\nA workflow is stored as a YAML file in the .github/workflows directory.\nIn our case we had to modify a predefined workflow from nbdev, because we have to install some non python packages which require root write permissions.\nPrecisely; we want to use the glpk solver in a nbdev project and therefore define a workflow in the following example.\n\n\n\nWe first give the content of the yaml-file and explain its parts afterwards.\nname: stochprog_test\non: [push]\n\npermissions: write-all\n\njobs:\n  build:\n\n    runs-on: ubuntu-20.04\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python 3.9\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n      - name: install solver\n        run : sudo apt-get install -y libopenmpi-dev glpk-utils\n      - name: poetry install\n        run: |\n          python -m pip install --upgrade pip\n          curl -sSL https://install.python-poetry.org | python3 -\n          poetry install\n      - uses: fastai/workflows/quarto-ghp@master\n      - uses: fastai/workflows/nbdev-ci@master\n\n\nFirst we specify the name of the workflow. The given name will be displayed in the action tab of your github repository.\n\n\n\nThen we specify the events which will trigger the workflow. - for single event use on: push - for multiple events use on: [push, fork] - list of events that trigger workflows - there are many other activity types to trigger a workflow, e.g. issue creation\n\n\n\nWe can modify the permissions granted to the GITHUB_-_TOKEN. For simplicyty we did this for all scopes, but the permissions can be granted to to different scopes and specific jobs.\n\n\n\nA workflow is made of one or more jobs which specify what has to be done. Here build is the name of the job, which is defined afterwards. In the build job we define\n\nruns-on: ubuntu-20.04 specifies the type of machine the job runs on\nsteps list the tasks of the job\n\nEach step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps\nuses: uses: fastai/workflows/quarto-ghp@master runs an action of the fastai public repository\n\nAs the virtual Linux machines run passwordless we can use sudo without providing a password but add option -y to confirm the installation. Put together: run : sudo apt-get install -y libopenmpi-dev glpk-utils\n\n\n\n\n\n\nchaching dependencies to improve performance"
  },
  {
    "objectID": "20221129_citation/index.html",
    "href": "20221129_citation/index.html",
    "title": "Citation and Footnotes in quarto",
    "section": "",
    "text": "footnotes:\n\nmarkdown footnote syntax (as I have to look this up regularly)\n\ncitations:\n\nexplain initial setup including a test\nexplain steps to generate citations and a bibliography with quarto"
  },
  {
    "objectID": "20221129_citation/index.html#input",
    "href": "20221129_citation/index.html#input",
    "title": "Citation and Footnotes in quarto",
    "section": "3.1 input",
    "text": "3.1 input\nHere is a footnote reference,[^1] and another.[^longnote]\n\n[^1]: Here is the footnote.\n[^longnote]: Here's one with multiple blocks.\n\n    Subsequent paragraphs are indented to show that they\nbelong to the previous footnote.\n\n        { some.code }\n\n    The whole paragraph can be indented, or just the first\n    line.  In this way, multi-paragraph footnotes work like\n    multi-paragraph list items.\n\nThis paragraph won't be part of the note, because it\nisn't indented.\nRemark: The content of the footnote, e.g. [^1]: Here is the footnote. can be placed anywhere in the document. I usually put it at the end of the document, because some footnotes are used more than once."
  },
  {
    "objectID": "20221129_citation/index.html#output",
    "href": "20221129_citation/index.html#output",
    "title": "Citation and Footnotes in quarto",
    "section": "3.2 output",
    "text": "3.2 output\nHere is a footnote reference,1 and another.2\nThis paragraph won’t be part of the note, because it isn’t indented."
  },
  {
    "objectID": "20221129_citation/index.html#inline-footnote",
    "href": "20221129_citation/index.html#inline-footnote",
    "title": "Citation and Footnotes in quarto",
    "section": "3.3 inline footnote",
    "text": "3.3 inline footnote\nHere is an inline note.^[Inlines notes are easier to write,\nsince you don't have to pick an identifier and move down to\ntype the note.]\nHere is an inline note.3"
  },
  {
    "objectID": "20221129_citation/index.html#bibliography-generation",
    "href": "20221129_citation/index.html#bibliography-generation",
    "title": "Citation and Footnotes in quarto",
    "section": "5.1 Bibliography Generation",
    "text": "5.1 Bibliography Generation\nSupose you want to add a new reference to your citation database references.bib, e.g. [@trotta2022pickup]. I usually do the following:\n\nopen google scholar\nsearch for your reference, e.g. “trotta routing on a ring”\nuse the nice link “citation” below the hit of google scholar and choose BibTex next\nsimply copy and paste the content to your references.bib file. The copied content will look like:\n\n@article{trotta2022pickup,\n  title={Pickup and delivery problems with autonomous vehicles on rings},\n  author={Trotta, Manuel and Archetti, Claudia and Feillet, Dominique and Quilliot, Alain},\n  journal={European Journal of Operational Research},\n  volume={300},\n  number={1},\n  pages={221--236},\n  year={2022},\n  publisher={Elsevier}\n}"
  },
  {
    "objectID": "20221129_citation/index.html#add-a-citation-in-a-blog-document",
    "href": "20221129_citation/index.html#add-a-citation-in-a-blog-document",
    "title": "Citation and Footnotes in quarto",
    "section": "5.2 Add a citation in a blog document",
    "text": "5.2 Add a citation in a blog document\n\nMarkdown format for citation is [@citation]\nGiven example: [@trotta2022pickup] renders to [@trotta2022pickup]\nThere are other markdown format for citation, e.g. @trotta2022pickup renders to @trotta2022pickup. For more information just have a look at the sources below."
  },
  {
    "objectID": "20221130_modeling_tips/index.html",
    "href": "20221130_modeling_tips/index.html",
    "title": "Linear programming tricks",
    "section": "",
    "text": "In this post we will see several tricks to transform certain models, for example models with nonlinear, features, into a conventional linear programming model. Because linear programming model provide the fastest and most powerful solution methods, it is often advisable to use this format instead of solving a nonlinear or integer programming model1 where possible.\nAs in this blog I mainly focus on a quick problem and solution description, mathematical details are skipped. As I devoted a detailed post for probabilistic or chance constraints, chance constraints are not discussed here.\nFor a more detailed presentation we refer to [@bisschop2006aimms, chapter 6.7].\n\n\nConsider the following model: \\[\n\\begin{array}{ll}\n\\min & \\sum_i c_i |x_i| \\\\\ns.t. & \\sum_j a_{ij}x_j \\leq b_i ,\\; \\forall i\n\\end{array}\n\\]\nDue to the presence of absolute values in the objective function we can not directly apply a linear programminng solver, but we can reformulate the problem as follows: \\[\n\\begin{array}{cl}\nx_i = & x_i^+ - x_i^- \\\\\n|x_i|=& x_i^+ + x_i^-\\\\\n      & x_i^+, x_i^- \\geq 0\n\\end{array}\n\\]\nThe above linear program can be rewritten as follows:\n\\[\n\\begin{array}{ll}\n\\min & \\sum_j c_j (x_j^+-x_j^-) \\\\\ns.t. & \\sum_j a_{ij}(x_j^+-x_j^-) \\geq b_i ,\\; \\forall i \\\\\n     & x_j^+, x_j^- \\geq 0\n\\end{array}\n\\]\nApplication: curve fitting, e.g. fitting a straight line through by least maximum deviation estimation.\n\n\n\nConsider the following model:\n\\[\n\\begin{array}{ll}\n\\min & \\max_k \\sum_j c_{kj}x_j \\\\\ns.t. & \\sum_j a_{ij}x_j \\leq b_i ,\\; \\forall i\\\\\n     & x_j \\geq 0\n\\end{array}\n\\]\nIn this objective we want to minimize a maximum. This is called a minimax objective.\nWe represent the maximum by introducing an additional decision variable \\(z\\), which will represent the maximal costs, \\[\nz = \\max \\sum_j c_{kj}x_j\n\\]\nand impose an extra constraint to establish the relationship:\n\\[\nz \\geq \\sum_j c_{kj}x_j, \\; \\forall k\n\\]\nThe equivalent linear programm is:\n\\[\n\\begin{array}{ll}\n\\min & z \\\\\ns.t. & \\sum_j a_{ij}x_j \\leq b_i ,\\; \\forall i\\\\\n     & \\sum_j c_{kj}x_j \\leq z, \\; \\forall k \\\\\n     & x_j \\geq 0     \n\\end{array}\n\\]\nThe problem ob maximizing a minimum can be reformulated in a similar fashion.\nApplication: curve fitting, e.g. fitting a straight line through by least maximum deviation estimation.\n\n\n\nConsider the following model:\n\\[\n\\begin{array}{ll}\n\\min & \\frac{\\sum_j c_j x_j +\\alpha}{\\sum_j d_j x_j + \\beta} \\\\\ns.t. & \\sum_j a_{ij}x_j \\leq b_i ,\\; \\forall i\\\\\n     & x_j \\geq 0\n\\end{array}\n\\]\nHere the objective is given as a ratio of two linear terms. It is assumed that the denominator is either positive or negative over the entire feasible set of \\(x_j\\).\nThe main trick is to introduce variables \\(y_j\\) and \\(t\\) such that \\(y_j=tx_j\\).\nIn the following explanation, we assume the value of the denominator to be positive. If it is negative, the directions in the inequalities must be reversed. We introduce a new variable for the denominator \\[\nt:=\\frac{1}{\\sum_j d_j x_j + \\beta}\n\\] and add an extra constraint \\(t\\geq 0\\). This yields the following model\n\\[\n\\begin{array}{ll}\n\\min & \\sum_j c_j x_j +\\alpha t\\\\\ns.t. & \\sum_j a_{ij}x_j \\leq b_i t,\\; \\forall i\\\\\n     & \\sum_j d_jy_j+\\beta t = 1 \\\\\n     & t \\geq 0 \\\\\n     & y_j \\geq 0\n\\end{array}\n\\]\n\n\n\nConsider the following model:\n\\[\n\\begin{array}{ll}\n\\min & \\sum_j c_j x_j \\\\\ns.t. & d_i \\leq \\sum_j a_{ij}x_j \\leq e_i ,\\; \\forall i\\\\\n     & x_j \\geq 0\n\\end{array}\n\\]\nApplication: blending problems, e.g. the minimal amout of a nutirent required in a blend and,at the same time, three is a limited amount available. The obvious way is to replace the range constraint by 2 constraints, but when a change occurs both constraints have to be maintained.\nWe introduce new variables \\(u_i\\) \\[\nu_i + \\sum_j a_{ij}x_j =e_i ,\\; \\forall i\n\\] and impose the constraints \\[\n0 \\leq u_i \\leq e_i -d_i , \\; \\forall i\n\\]\nThe equivalent linear programm is:\n\\[\n\\begin{array}{ll}\n\\min & \\sum_j c_j x_j \\\\\ns.t. & u_i + \\sum_j a_{ij}x_j =e_i ,\\; \\forall i \\\\\n     & 0 \\leq u_i \\leq e_i -d_i , \\; \\forall i \\\\\n     & x_j \\geq 0\n\\end{array}\n\\]"
  },
  {
    "objectID": "20221127_jupyter_test/index.html",
    "href": "20221127_jupyter_test/index.html",
    "title": "Pyomo and solver test",
    "section": "",
    "text": "We give the implementation of a simple model in pyomo to test the correct installation and in particular the solvers.\nExpectation: code is executed without errors\n\n\nconda env create -f environment.yml\nconda activate blog\n\nimport pyomo.environ as pyo\n\n\nmodel = pyo.ConcreteModel()\n\nmodel.x = pyo.Var([1,2], domain=pyo.NonNegativeReals)\n\nmodel.OBJ = pyo.Objective(expr = 2*model.x[1] + 3*model.x[2])\n\nmodel.Constraint1 = pyo.Constraint(expr = 3*model.x[1] + 4*model.x[2] >= 1)\n\n\nglpk_test = pyo.SolverFactory('glpk')\n#cbc_test = pyo.SolverFactory('cbc')\n#ipopt_test = pyo.SolverFactory('ipopt')\n\n\n#glpk_test.solve(model)\n\n{'Problem': [{'Name': 'unknown', 'Lower bound': 0.666666666666667, 'Upper bound': 0.666666666666667, 'Number of objectives': 1, 'Number of constraints': 2, 'Number of variables': 3, 'Number of nonzeros': 3, 'Sense': 'minimize'}], 'Solver': [{'Status': 'ok', 'Termination condition': 'optimal', 'Statistics': {'Branch and bound': {'Number of bounded subproblems': 0, 'Number of created subproblems': 0}}, 'Error rc': 0, 'Time': 0.013138532638549805}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value             : Upper : Fixed : Stale : Domain\n          1 :     0 : 0.333333333333333 :  None : False : False : NonNegativeReals\n          2 :     0 :               0.0 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1\n\n\n\n##cbc_test.solve(model)\n\n{'Problem': [{'Name': 'unknown', 'Lower bound': 0.6666666667, 'Upper bound': 0.6666666667, 'Number of objectives': 1, 'Number of constraints': 2, 'Number of variables': 3, 'Number of nonzeros': 0, 'Sense': 'minimize'}], 'Solver': [{'Status': 'ok', 'User time': -1.0, 'System time': 0.0, 'Wallclock time': 0.0, 'Termination condition': 'optimal', 'Termination message': 'Model was solved to optimality (subject to tolerances), and an optimal solution is available.', 'Statistics': {'Branch and bound': {'Number of bounded subproblems': None, 'Number of created subproblems': None}, 'Black box': {'Number of iterations': 0}}, 'Error rc': 0, 'Time': 0.04025125503540039}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value      : Upper : Fixed : Stale : Domain\n          1 :     0 : 0.33333333 :  None : False : False : NonNegativeReals\n          2 :     0 :        0.0 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1\n\n\n\n##ipopt_test.solve(model)\n\n{'Problem': [{'Lower bound': -inf, 'Upper bound': inf, 'Number of objectives': 1, 'Number of constraints': 1, 'Number of variables': 2, 'Sense': 'unknown'}], 'Solver': [{'Status': 'ok', 'Message': 'Ipopt 3.14.11\\\\x3a Optimal Solution Found', 'Termination condition': 'optimal', 'Id': 0, 'Error rc': 0, 'Time': 0.05022311210632324}], 'Solution': [OrderedDict([('number of solutions', 0), ('number of solutions displayed', 0)])]}\n\n\n\nmodel.pprint()\n\n1 Set Declarations\n    x_index : Size=1, Index=None, Ordered=Insertion\n        Key  : Dimen : Domain : Size : Members\n        None :     1 :    Any :    2 : {1, 2}\n\n1 Var Declarations\n    x : Size=2, Index=x_index\n        Key : Lower : Value                   : Upper : Fixed : Stale : Domain\n          1 :     0 :      0.3333333343972087 :  None : False : False : NonNegativeReals\n          2 :     0 : -2.3599945501636825e-09 :  None : False : False : NonNegativeReals\n\n1 Objective Declarations\n    OBJ : Size=1, Index=None, Active=True\n        Key  : Active : Sense    : Expression\n        None :   True : minimize : 2*x[1] + 3*x[2]\n\n1 Constraint Declarations\n    Constraint1 : Size=1, Index=None, Active=True\n        Key  : Lower : Body            : Upper : Active\n        None :   1.0 : 3*x[1] + 4*x[2] :  +Inf :   True\n\n4 Declarations: x_index x OBJ Constraint1"
  }
]